<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸš¨ ë‹¤ì¤‘ë°© í†µí•© í‰ë©´ë„ ìƒì„±ê¸°</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 450px;
            margin: 0 auto;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        h1 {
            text-align: center;
            color: #d32f2f;
            margin-bottom: 10px;
            font-size: 20px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-bottom: 20px;
        }
        
        .status {
            padding: 12px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
            font-size: 14px;
        }
        
        .status.info { background: #e3f2fd; color: #1976d2; border: 2px solid #2196f3; }
        .status.success { background: #e8f5e8; color: #2e7d32; border: 2px solid #4caf50; }
        .status.error { background: #ffebee; color: #c62828; border: 2px solid #f44336; }
        .status.warning { background: #fff3e0; color: #f57c00; border: 2px solid #ff9800; }
        
        video, canvas {
            width: 100%;
            border-radius: 8px;
            margin: 10px 0;
            background: #000;
        }
        
        button {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary { background: #2196f3; color: white; }
        .btn-primary:hover { background: #1976d2; }
        .btn-success { background: #4caf50; color: white; }
        .btn-success:hover { background: #388e3c; }
        .btn-danger { background: #f44336; color: white; }
        .btn-danger:hover { background: #d32f2f; }
        .btn-warning { background: #ff9800; color: white; }
        .btn-warning:hover { background: #f57c00; }
        .btn-secondary { background: #9c27b0; color: white; }
        .btn-secondary:hover { background: #7b1fa2; }
        
        button:disabled { background: #ccc; cursor: not-allowed; }
        
        .mode-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #dee2e6;
        }
        
        .mode-card {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid #dee2e6;
        }
        
        .mode-card.active {
            border-color: #2196f3;
            background: #e3f2fd;
        }
        
        .mode-card:hover {
            background: #f0f0f0;
        }
        
        .guide-box {
            background: #f0f4ff;
            border: 2px solid #2196f3;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-size: 14px;
        }
        
        .guide-box h4 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }
        
        .room-list {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .room-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }
        
        .room-item.current {
            border-color: #4caf50;
            background: #e8f5e8;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin: 15px 0;
        }
        
        .metric {
            text-align: center;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 6px;
            font-size: 12px;
        }
        
        .metric-value {
            font-size: 16px;
            font-weight: bold;
            color: #2196f3;
        }
        
        .path-indicator {
            text-align: center;
            padding: 15px;
            margin: 15px 0;
            background: #fff3e0;
            border-radius: 8px;
            border: 2px solid #ff9800;
            display: none;
        }
        
        .path-indicator.show { display: block; }
        
        .building-map {
            border: 2px solid #4caf50;
            background: #f8fff8;
            margin: 15px 0;
        }
        
        .debug-info {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 11px;
            max-height: 150px;
            overflow-y: auto;
            display: none;
        }
        
        .show-debug { display: block; }
        
        .emergency-tip {
            background: #ffebee;
            border: 2px solid #f44336;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
            color: #c62828;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš¨ ë‹¤ì¤‘ë°© í†µí•© í‰ë©´ë„ ìƒì„±ê¸°</h1>
        <div class="subtitle">ë°©ë³„ ìŠ¤ìº” + ì´ë™ ê²½ë¡œ ì¶”ì  ğŸ â¡ï¸ğŸ </div>
        
        <div class="mode-selector">
            <div class="mode-card active" id="roomMode">
                <h4>ğŸ”„ ë°© ìŠ¤ìº” ëª¨ë“œ</h4>
                <div style="font-size: 12px;">ë°© ì¤‘ì•™ì—ì„œ 360ë„ íšŒì „</div>
            </div>
            <div class="mode-card" id="pathMode">
                <h4>ğŸš¶ ì´ë™ ëª¨ë“œ</h4>
                <div style="font-size: 12px;">ë°© ì‚¬ì´ ê²½ë¡œ ì¶”ì </div>
            </div>
        </div>
        
        <div class="guide-box">
            <h4 id="guideTitle">ğŸ¯ ë°© ìŠ¤ìº” ëª¨ë“œ</h4>
            <div id="guideText">
                1ï¸âƒ£ ì²« ë²ˆì§¸ ë°© ì¤‘ì•™ì— ì„œê¸°<br>
                2ï¸âƒ£ "ë°© ìŠ¤ìº”" ë²„íŠ¼ìœ¼ë¡œ 360ë„ íšŒì „<br>
                3ï¸âƒ£ "ì´ë™ ëª¨ë“œ"ë¡œ ë³€ê²½ í›„ ë‹¤ìŒ ë°©ìœ¼ë¡œ<br>
                4ï¸âƒ£ ë°˜ë³µí•˜ì—¬ ëª¨ë“  ë°© ìŠ¤ìº” ì™„ë£Œ!
            </div>
        </div>
        
        <div class="emergency-tip">
            ğŸš¨ <strong>í™”ì¬í˜„ì¥ í™œìš©:</strong> ê° ë°© + ë³µë„/ê³„ë‹¨ ì—°ê²° ê´€ê³„ íŒŒì•…ìœ¼ë¡œ ì „ì²´ êµ¬ì¡° ë§¤í•‘
        </div>
        
        <div id="status" class="status info">ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...</div>
        
        <div class="room-list">
            <h4>ğŸ“‹ ìŠ¤ìº”ëœ ë°© ëª©ë¡</h4>
            <div id="roomListContainer">
                <div style="text-align: center; color: #666; font-size: 12px;">
                    ì•„ì§ ìŠ¤ìº”ëœ ë°©ì´ ì—†ìŠµë‹ˆë‹¤
                </div>
            </div>
            <button id="newRoomBtn" class="btn-secondary" disabled>â• ìƒˆ ë°© ì¶”ê°€</button>
        </div>
        
        <video id="video" autoplay playsinline muted style="display: none;"></video>
        <canvas id="processCanvas" style="display: none;"></canvas>
        
        <div class="path-indicator" id="pathIndicator">
            <div><strong>ğŸš¶ ë°© ì‚¬ì´ ì´ë™ ì¤‘...</strong></div>
            <div>í˜„ì¬ ê²½ë¡œë¥¼ ì¶”ì í•˜ê³  ìˆìŠµë‹ˆë‹¤</div>
            <div style="font-size: 12px; margin-top: 5px;">ë‹¤ìŒ ë°©ì— ë„ì°©í•˜ë©´ "ë°© ìŠ¤ìº” ëª¨ë“œ"ë¡œ ë³€ê²½í•˜ì„¸ìš”</div>
        </div>
        
        <canvas id="buildingMap" class="building-map" width="400" height="400" style="display: none;"></canvas>
        
        <div class="metrics" id="metrics" style="display: none;">
            <div class="metric">
                <div class="metric-value" id="roomCount">0</div>
                <div>ìŠ¤ìº”ëœ ë°©</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="connectionCount">0</div>
                <div>ì—°ê²° ê²½ë¡œ</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="totalArea">0ã¡</div>
                <div>ì´ ë©´ì </div>
            </div>
        </div>
        
        <div class="controls">
            <button id="startBtn" class="btn-primary">ğŸ“¹ ì¹´ë©”ë¼ ì‹œì‘</button>
            <button id="scanBtn" class="btn-success" disabled>ğŸ”„ ìŠ¤ìº” ì‹œì‘</button>
            <button id="stopBtn" class="btn-danger" disabled>â¹ï¸ ì¤‘ì§€</button>
            <button id="completeBtn" class="btn-warning" disabled>âœ… ì „ì²´ ì™„ë£Œ</button>
        </div>
        
        <button id="debugBtn" class="btn-primary" style="font-size: 12px;">ğŸ”§ ë””ë²„ê·¸ ì •ë³´</button>
        
        <div class="debug-info" id="debugInfo">
            === ë‹¤ì¤‘ë°© ìŠ¤ìº” ì‹œìŠ¤í…œ ì‹œì‘ ===<br>
        </div>
        
        <div id="results" style="display: none;">
            <h3 style="color: #2196f3; margin: 20px 0 10px 0;">ğŸ¢ ì „ì²´ ê±´ë¬¼ í‰ë©´ë„</h3>
            <canvas id="finalMap" width="400" height="400" style="border: 2px solid #2196f3;"></canvas>
            <div id="buildingInfo" style="margin-top: 10px;"></div>
        </div>
    </div>

    <!-- OpenCV.js ë¡œë“œ -->
    <script async src="https://docs.opencv.org/4.5.2/opencv.js" type="text/javascript"></script>
    
    <script>
        // ì „ì—­ ë³€ìˆ˜
        let video, processCanvas, buildingMap, finalMap;
        let startBtn, scanBtn, stopBtn, completeBtn, debugBtn, newRoomBtn;
        let roomMode, pathMode, status, debugInfo, metrics, pathIndicator;
        let stream = null;
        let isScanning = false;
        let currentMode = 'room'; // 'room' ë˜ëŠ” 'path'
        let frameCount = 0;
        
        // ë‹¤ì¤‘ë°© ë°ì´í„° êµ¬ì¡°
        let building = {
            rooms: [],           // ê° ë°©ì˜ ì •ë³´
            connections: [],     // ë°© ì‚¬ì´ ì—°ê²° ì •ë³´
            currentRoom: null,   // í˜„ì¬ ìŠ¤ìº” ì¤‘ì¸ ë°©
            totalArea: 0,        // ì „ì²´ ë©´ì 
            centerPoint: {x: 200, y: 200} // ê±´ë¬¼ ì¤‘ì‹¬ì 
        };
        
        // í˜„ì¬ ìŠ¤ìº” ë°ì´í„°
        let currentScanData = {
            roomId: null,
            wallDistances: {},
            position: {x: 0, y: 0},
            rotation: 0,
            pathPoints: []
        };
        
        // ì„¼ì„œ ë°ì´í„°
        let gyroData = {x: 0, y: 0, z: 0};
        let previousPosition = null;
        
        // OpenCV ê´€ë ¨
        let detector = null;
        
        // ë¡œê·¸ í•¨ìˆ˜
        function log(message) {
            console.log(message);
            const now = new Date().toLocaleTimeString();
            if (debugInfo) {
                debugInfo.innerHTML += `[${now}] ${message}<br>`;
                debugInfo.scrollTop = debugInfo.scrollHeight;
            }
        }
        
        // ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateStatus(message, type = 'info') {
            console.log(`ìƒíƒœ: ${message}`);
            if (status) {
                status.textContent = message;
                status.className = `status ${type}`;
            }
            log(`ìƒíƒœ: ${message}`);
        }
        
        // ëª¨ë“œ ë³€ê²½
        function switchMode(newMode) {
            currentMode = newMode;
            
            // UI ì—…ë°ì´íŠ¸
            roomMode.classList.toggle('active', newMode === 'room');
            pathMode.classList.toggle('active', newMode === 'path');
            pathIndicator.classList.toggle('show', newMode === 'path');
            
            if (newMode === 'room') {
                document.getElementById('guideTitle').textContent = 'ğŸ¯ ë°© ìŠ¤ìº” ëª¨ë“œ';
                document.getElementById('guideText').innerHTML = `
                    ğŸ”„ í˜„ì¬: ë°© ${building.rooms.length + 1} ìŠ¤ìº”<br>
                    â€¢ ë°© ì¤‘ì•™ì— ì„œì„œ 360ë„ íšŒì „<br>
                    â€¢ ì™„ë£Œ í›„ "ì´ë™ ëª¨ë“œ"ë¡œ ë³€ê²½<br>
                    â€¢ ë‹¤ìŒ ë°©ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”
                `;
                scanBtn.textContent = 'ğŸ”„ ë°© ìŠ¤ìº” ì‹œì‘';
                
            } else { // path ëª¨ë“œ
                document.getElementById('guideTitle').textContent = 'ğŸš¶ ì´ë™ ëª¨ë“œ (ë³µë„ ê°ì§€)';
                document.getElementById('guideText').innerHTML = `
                    ğŸš¶ ë‹¤ìŒ ë°©ìœ¼ë¡œ ì´ë™ ì¤‘...<br>
                    â€¢ ë³µë„ ì–‘ìª½ ë²½ê¹Œì§€ì˜ ê±°ë¦¬ ìë™ ì¸¡ì •<br>
                    â€¢ ë³µë„ í­ê³¼ ëª¨ì–‘ì´ ì‹¤ì‹œê°„ ê°ì§€ë©ë‹ˆë‹¤<br>
                    â€¢ ë‹¤ìŒ ë°© ì¤‘ì•™ì— ë„ì°©í•˜ë©´ "ë°© ìŠ¤ìº” ëª¨ë“œ"ë¡œ ë³€ê²½
                `;
                scanBtn.textContent = 'ğŸš¶ ë³µë„ ì¶”ì  ì‹œì‘';
            }
            
            log(`ëª¨ë“œ ë³€ê²½: ${newMode}`);
        }
        
        // ë°© ëª©ë¡ ì—…ë°ì´íŠ¸
        function updateRoomList() {
            const container = document.getElementById('roomListContainer');
            
            if (building.rooms.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; color: #666; font-size: 12px;">
                        ì•„ì§ ìŠ¤ìº”ëœ ë°©ì´ ì—†ìŠµë‹ˆë‹¤
                    </div>
                `;
            } else {
                let html = '';
                building.rooms.forEach((room, index) => {
                    const isCurrent = room.id === building.currentRoom;
                    html += `
                        <div class="room-item ${isCurrent ? 'current' : ''}">
                            <div>
                                <strong>${room.name}</strong><br>
                                <span style="font-size: 12px; color: #666;">
                                    ${room.area.toFixed(1)}ã¡ | ${room.confidence}% ì‹ ë¢°ë„
                                </span>
                            </div>
                            <div style="font-size: 12px; color: ${room.completed ? '#4caf50' : '#ff9800'};">
                                ${room.completed ? 'âœ… ì™„ë£Œ' : 'ğŸ”„ ì§„í–‰ì¤‘'}
                            </div>
                        </div>
                    `;
                });
                container.innerHTML = html;
            }
            
            // ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
            if (document.getElementById('roomCount')) {
                document.getElementById('roomCount').textContent = building.rooms.length;
                document.getElementById('connectionCount').textContent = building.connections.length;
                document.getElementById('totalArea').textContent = building.totalArea.toFixed(1) + 'ã¡';
            }
        }
        
        // ì„¼ì„œ ì´ˆê¸°í™”
        function initializeSensors() {
            if (typeof DeviceMotionEvent !== 'undefined') {
                window.addEventListener('devicemotion', function(event) {
                    if (event.rotationRate && isScanning) {
                        gyroData = event.rotationRate;
                        
                        if (currentMode === 'room') {
                            // ë°© ìŠ¤ìº” ëª¨ë“œ: íšŒì „ ì¶”ì 
                            if (gyroData.z !== null) {
                                currentScanData.rotation += gyroData.z * 0.1;
                                currentScanData.rotation = ((currentScanData.rotation % 360) + 360) % 360;
                            }
                        } else {
                            // ì´ë™ ëª¨ë“œ: ìœ„ì¹˜ ì¶”ì 
                            updatePositionFromSensors(event);
                        }
                    }
                });
                log('ì„¼ì„œ ì´ˆê¸°í™” ì™„ë£Œ');
            }
            
            // iOS ê¶Œí•œ ìš”ì²­
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission().then(response => {
                    log(`ì„¼ì„œ ê¶Œí•œ: ${response}`);
                });
            }
        }
        
        // ì„¼ì„œì—ì„œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ì´ë™ ëª¨ë“œìš©)
        function updatePositionFromSensors(event) {
            if (event.acceleration) {
                const accel = event.acceleration;
                const speed = Math.sqrt(accel.x**2 + accel.y**2 + accel.z**2);
                
                if (speed > 0.5) { // ì›€ì§ì„ ê°ì§€
                    // ê°„ë‹¨í•œ ìœ„ì¹˜ ì¶”ì • (ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ê³„ì‚° í•„ìš”)
                    const movement = speed * 0.1;
                    const angle = currentScanData.rotation * Math.PI / 180;
                    
                    currentScanData.position.x += movement * Math.cos(angle);
                    currentScanData.position.y += movement * Math.sin(angle);
                    
                    // ê²½ë¡œ ì  ì¶”ê°€
                    currentScanData.pathPoints.push({
                        x: currentScanData.position.x,
                        y: currentScanData.position.y,
                        timestamp: Date.now()
                    });
                }
            }
        }
        
        // OpenCV ì´ˆê¸°í™” ëŒ€ê¸°
        function waitForOpenCV() {
            return new Promise((resolve) => {
                if (typeof cv !== 'undefined') {
                    resolve();
                } else {
                    const checkInterval = setInterval(() => {
                        if (typeof cv !== 'undefined') {
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 100);
                }
            });
        }
        
        // DOM ë¡œë“œ ì™„ë£Œ ì‹œ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', async function() {
            log('ë‹¤ì¤‘ë°© í†µí•© ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹œì‘');
            
            // ìš”ì†Œë“¤ ê°€ì ¸ì˜¤ê¸°
            video = document.getElementById('video');
            processCanvas = document.getElementById('processCanvas');
            buildingMap = document.getElementById('buildingMap');
            finalMap = document.getElementById('finalMap');
            
            startBtn = document.getElementById('startBtn');
            scanBtn = document.getElementById('scanBtn');
            stopBtn = document.getElementById('stopBtn');
            completeBtn = document.getElementById('completeBtn');
            debugBtn = document.getElementById('debugBtn');
            newRoomBtn = document.getElementById('newRoomBtn');
            
            roomMode = document.getElementById('roomMode');
            pathMode = document.getElementById('pathMode');
            status = document.getElementById('status');
            debugInfo = document.getElementById('debugInfo');
            metrics = document.getElementById('metrics');
            pathIndicator = document.getElementById('pathIndicator');
            
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
            startBtn.addEventListener('click', startCamera);
            scanBtn.addEventListener('click', startScan);
            stopBtn.addEventListener('click', stopScan);
            completeBtn.addEventListener('click', completeBuilding);
            debugBtn.addEventListener('click', toggleDebug);
            newRoomBtn.addEventListener('click', addNewRoom);
            
            roomMode.addEventListener('click', () => switchMode('room'));
            pathMode.addEventListener('click', () => switchMode('path'));
            
            log('ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ ì™„ë£Œ');
            
            // ì´ˆê¸° UI ì„¤ì •
            updateRoomList();
            
            // ì„¼ì„œ ì´ˆê¸°í™”
            initializeSensors();
            
            // OpenCV ë¡œë”© ëŒ€ê¸°
            updateStatus('OpenCV.js ë¡œë”© ì¤‘...', 'info');
            await waitForOpenCV();
            
            // OpenCV ì´ˆê¸°í™”
            initializeOpenCV();
            
            updateStatus('ì¤€ë¹„ ì™„ë£Œ! ì²« ë²ˆì§¸ ë°©ì—ì„œ ì¹´ë©”ë¼ë¥¼ ì‹œì‘í•˜ì„¸ìš”', 'success');
        });
        
        // OpenCV ì´ˆê¸°í™”
        function initializeOpenCV() {
            try {
                detector = new cv.ORB(500);
                processCanvas.width = 640;
                processCanvas.height = 480;
                log('OpenCV ë‹¤ì¤‘ë°© ìŠ¤ìº”ìš© ì´ˆê¸°í™” ì™„ë£Œ');
            } catch (error) {
                log(`OpenCV ì´ˆê¸°í™” ì˜¤ë¥˜: ${error.message}`);
                updateStatus('OpenCV ì´ˆê¸°í™” ì‹¤íŒ¨', 'error');
            }
        }
        
        // ì¹´ë©”ë¼ ì‹œì‘
        async function startCamera() {
            log('ì¹´ë©”ë¼ ì‹œì‘ ì‹œë„...');
            updateStatus('ì¹´ë©”ë¼ ê¶Œí•œ ìš”ì²­ ì¤‘...', 'info');
            
            try {
                const constraints = {
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                video.style.display = 'block';
                
                video.onloadedmetadata = function() {
                    log(`ë¹„ë””ì˜¤ í•´ìƒë„: ${video.videoWidth}x${video.videoHeight}`);
                    updateStatus('ì¹´ë©”ë¼ ì¤€ë¹„ ì™„ë£Œ! ìŠ¤ìº”ì„ ì‹œì‘í•˜ì„¸ìš”', 'success');
                    startBtn.disabled = true;
                    scanBtn.disabled = false;
                    newRoomBtn.disabled = false;
                    buildingMap.style.display = 'block';
                    metrics.style.display = 'grid';
                };
                
            } catch (error) {
                log(`ì¹´ë©”ë¼ ì˜¤ë¥˜: ${error.message}`);
                updateStatus(`ì¹´ë©”ë¼ ì˜¤ë¥˜: ${error.message}`, 'error');
                
                if (error.name === 'NotAllowedError') {
                    alert('ì¹´ë©”ë¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”!');
                }
            }
        }
        
        // ìŠ¤ìº” ì‹œì‘
        function startScan() {
            if (!stream) {
                alert('ë¨¼ì € ì¹´ë©”ë¼ë¥¼ ì‹œì‘í•´ì£¼ì„¸ìš”');
                return;
            }
            
            log(`${currentMode} ëª¨ë“œ ìŠ¤ìº” ì‹œì‘`);
            isScanning = true;
            
            // UI ì—…ë°ì´íŠ¸
            scanBtn.disabled = true;
            stopBtn.disabled = false;
            
            if (currentMode === 'room') {
                startRoomScan();
            } else {
                startPathTracking();
            }
            
            // ì‹¤ì‹œê°„ ì²˜ë¦¬ ì‹œì‘
            processFrames();
        }
        
        // ë°© ìŠ¤ìº” ì‹œì‘
        function startRoomScan() {
            // ìƒˆ ë°© ìƒì„±
            const roomId = `room_${building.rooms.length + 1}`;
            const newRoom = {
                id: roomId,
                name: `ë°© ${building.rooms.length + 1}`,
                wallDistances: {},
                polygon: [],
                area: 0,
                center: {...currentScanData.position},
                completed: false,
                confidence: 0
            };
            
            building.rooms.push(newRoom);
            building.currentRoom = roomId;
            
            // ìŠ¤ìº” ë°ì´í„° ì´ˆê¸°í™”
            currentScanData.roomId = roomId;
            currentScanData.wallDistances = {};
            currentScanData.rotation = 0;
            
            updateStatus(`ğŸ”„ ë°© ${building.rooms.length} ìŠ¤ìº” ì¤‘...`, 'warning');
            updateRoomList();
            
            log(`ìƒˆ ë°© ìƒì„±: ${roomId}`);
        }
        
        // ê²½ë¡œ ì¶”ì  ì‹œì‘
        function startPathTracking() {
            currentScanData.pathPoints = [];
            previousPosition = {...currentScanData.position};
            
            updateStatus('ğŸš¶ ë°© ì‚¬ì´ ì´ë™ ê²½ë¡œ ì¶”ì  ì¤‘...', 'warning');
            log('ê²½ë¡œ ì¶”ì  ì‹œì‘');
        }
        
        // í”„ë ˆì„ ì²˜ë¦¬
        async function processFrames() {
            if (!isScanning) return;
            
            try {
                const ctx = processCanvas.getContext('2d');
                ctx.drawImage(video, 0, 0, processCanvas.width, processCanvas.height);
                
                frameCount++;
                
                if (currentMode === 'room') {
                    await processRoomScan();
                } else {
                    await processPathTracking();
                }
                
                // ê±´ë¬¼ ë§µ ê·¸ë¦¬ê¸°
                drawBuildingMap();
                
                // ë‹¤ìŒ í”„ë ˆì„ ì²˜ë¦¬
                setTimeout(processFrames, 200);
                
            } catch (error) {
                log(`í”„ë ˆì„ ì²˜ë¦¬ ì˜¤ë¥˜: ${error.message}`);
                setTimeout(processFrames, 200);
            }
        }
        
        // ë°© ìŠ¤ìº” ì²˜ë¦¬
        async function processRoomScan() {
            try {
                // OpenCV ë§¤íŠ¸ë¦­ìŠ¤ ìƒì„±
                const src = cv.imread(processCanvas);
                const gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // ì—£ì§€ ê²€ì¶œ
                const edges = new cv.Mat();
                cv.Canny(gray, edges, 50, 150);
                
                // í˜„ì¬ ë°©í–¥ì—ì„œ ë²½ê¹Œì§€ ê±°ë¦¬ ì¸¡ì •
                const centerX = processCanvas.width / 2;
                const centerY = processCanvas.height / 2;
                
                for (let offsetAngle = -30; offsetAngle <= 30; offsetAngle += 10) {
                    const rayAngle = currentScanData.rotation + offsetAngle;
                    const distance = castRayForWall(edges, centerX, centerY, rayAngle);
                    
                    if (distance > 0) {
                        currentScanData.wallDistances[Math.round(rayAngle) % 360] = distance;
                        
                        // í˜„ì¬ ë°© ë°ì´í„° ì—…ë°ì´íŠ¸
                        const currentRoom = building.rooms.find(r => r.id === building.currentRoom);
                        if (currentRoom) {
                            currentRoom.wallDistances[Math.round(rayAngle) % 360] = distance;
                        }
                    }
                }
                
                // ë©”ëª¨ë¦¬ ì •ë¦¬
                src.delete();
                gray.delete();
                edges.delete();
                
            } catch (error) {
                log(`ë°© ìŠ¤ìº” ì²˜ë¦¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }
        
        // ê²½ë¡œ ì¶”ì  ì²˜ë¦¬ (ë³µë„ ëª¨ì–‘ ê°ì§€ í¬í•¨)
        async function processPathTracking() {
            try {
                // ì‹œê°ì  íŠ¹ì§•ì ìœ¼ë¡œ ì´ë™ ê°ì§€
                const src = cv.imread(processCanvas);
                const gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // ì—£ì§€ ê²€ì¶œë¡œ ë³µë„ ë²½ë©´ ê°ì§€
                const edges = new cv.Mat();
                cv.Canny(gray, edges, 50, 150);
                
                // ë³µë„ ì–‘ì˜† ë²½ê¹Œì§€ì˜ ê±°ë¦¬ ì¸¡ì •
                const centerX = processCanvas.width / 2;
                const centerY = processCanvas.height / 2;
                
                const leftDistance = castRayForWall(edges, centerX, centerY, currentScanData.rotation - 90); // ì™¼ìª½
                const rightDistance = castRayForWall(edges, centerX, centerY, currentScanData.rotation + 90); // ì˜¤ë¥¸ìª½
                const frontDistance = castRayForWall(edges, centerX, centerY, currentScanData.rotation); // ì•ìª½
                
                // íŠ¹ì§•ì  ê²€ì¶œë¡œ ì´ë™ëŸ‰ ì¶”ì •
                const keypoints = new cv.KeyPointVector();
                const descriptors = new cv.Mat();
                detector.detectAndCompute(gray, new cv.Mat(), keypoints, descriptors);
                
                if (previousPosition && keypoints.size() > 10) {
                    // ê°„ë‹¨í•œ ì´ë™ ì¶”ì • (ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ê³„ì‚°)
                    const movement = estimateMovementFromFeatures(keypoints);
                    
                    currentScanData.position.x += movement.dx;
                    currentScanData.position.y += movement.dy;
                    
                    // ë³µë„ ì •ë³´ë¥¼ í¬í•¨í•œ ê²½ë¡œ ì  ì¶”ê°€
                    currentScanData.pathPoints.push({
                        x: currentScanData.position.x,
                        y: currentScanData.position.y,
                        leftWall: leftDistance,
                        rightWall: rightDistance,
                        frontWall: frontDistance,
                        corridorWidth: leftDistance + rightDistance,
                        timestamp: Date.now()
                    });
                    
                    log(`ë³µë„ ê°ì§€ - í­: ${(leftDistance + rightDistance) * 0.05}m, ì¢Œë²½: ${leftDistance * 0.05}m, ìš°ë²½: ${rightDistance * 0.05}m`);
                }
                
                // ë©”ëª¨ë¦¬ ì •ë¦¬
                src.delete();
                gray.delete();
                edges.delete();
                keypoints.delete();
                descriptors.delete();
                
            } catch (error) {
                log(`ê²½ë¡œ ì¶”ì  ì²˜ë¦¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }
        
        // Ray castingìœ¼ë¡œ ë²½ ê±°ë¦¬ ì¸¡ì •
        function castRayForWall(edges, startX, startY, angleDegrees) {
            const angleRadians = angleDegrees * Math.PI / 180;
            const maxDistance = 200;
            
            for (let distance = 20; distance < maxDistance; distance += 5) {
                const x = Math.round(startX + distance * Math.cos(angleRadians));
                const y = Math.round(startY + distance * Math.sin(angleRadians));
                
                if (x < 0 || x >= edges.cols || y < 0 || y >= edges.rows) {
                    return distance;
                }
                
                const pixelValue = edges.ucharPtr(y, x)[0];
                if (pixelValue > 100) {
                    return distance;
                }
            }
            
            return maxDistance;
        }
        
        // íŠ¹ì§•ì ì—ì„œ ì´ë™ ì¶”ì •
        function estimateMovementFromFeatures(keypoints) {
            // ê°„ë‹¨í•œ ì´ë™ ì¶”ì • (ì‹¤ì œë¡œëŠ” optical flow ë“± ì‚¬ìš©)
            return {
                dx: (Math.random() - 0.5) * 2, // ì„ì‹œ êµ¬í˜„
                dy: (Math.random() - 0.5) * 2
            };
        }
        
        // ê±´ë¬¼ ë§µ ê·¸ë¦¬ê¸°
        function drawBuildingMap() {
            const ctx = buildingMap.getContext('2d');
            ctx.clearRect(0, 0, buildingMap.width, buildingMap.height);
            
            // ë°°ê²½ ê²©ì
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let x = 0; x <= 400; x += 20) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 400);
                ctx.stroke();
            }
            for (let y = 0; y <= 400; y += 20) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(400, y);
                ctx.stroke();
            }
            
            // ìŠ¤ìº”ëœ ë°©ë“¤ ê·¸ë¦¬ê¸°
            building.rooms.forEach((room, index) => {
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f39c12', '#9b59b6'];
                const color = colors[index % colors.length];
                
                // ë°© ë‹¤ê°í˜• (ê°„ë‹¨í•œ ì›ìœ¼ë¡œ í‘œì‹œ)
                const roomX = 100 + (index % 3) * 120;
                const roomY = 100 + Math.floor(index / 3) * 120;
                
                ctx.fillStyle = color + '40';
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(roomX, roomY, 40, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // ë°© ë²ˆí˜¸
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(room.name, roomX, roomY + 5);
                
                // ì™„ë£Œ í‘œì‹œ
                if (room.completed) {
                    ctx.fillStyle = '#4caf50';
                    ctx.font = '16px Arial';
                    ctx.fillText('âœ…', roomX + 30, roomY - 30);
                }
                
                // í˜„ì¬ ìŠ¤ìº” ì¤‘ í‘œì‹œ
                if (room.id === building.currentRoom) {
                    ctx.strokeStyle = '#f44336';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(roomX, roomY, 45, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
            
            // ì—°ê²°ì„  ê·¸ë¦¬ê¸°
            building.connections.forEach(connection => {
                const room1Index = building.rooms.findIndex(r => r.id === connection.from);
                const room2Index = building.rooms.findIndex(r => r.id === connection.to);
                
                if (room1Index >= 0 && room2Index >= 0) {
                    const x1 = 100 + (room1Index % 3) * 120;
                    const y1 = 100 + Math.floor(room1Index / 3) * 120;
                    const x2 = 100 + (room2Index % 3) * 120;
                    const y2 = 100 + Math.floor(room2Index / 3) * 120;
                    
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
            
            // ì œëª©
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ğŸ¢ ê±´ë¬¼ ì „ì²´ êµ¬ì¡°', 200, 25);
        }
        
        // ìŠ¤ìº” ì¤‘ì§€
        function stopScan() {
            log('ìŠ¤ìº” ì¤‘ì§€');
            isScanning = false;
            
            scanBtn.disabled = false;
            stopBtn.disabled = true;
            
            if (currentMode === 'room') {
                completeCurrentRoom();
            } else {
                completePathConnection();
            }
        }
        
        // í˜„ì¬ ë°© ìŠ¤ìº” ì™„ë£Œ
        function completeCurrentRoom() {
            const currentRoom = building.rooms.find(r => r.id === building.currentRoom);
            if (currentRoom) {
                // ë°© ë‹¤ê°í˜• ìƒì„±
                currentRoom.polygon = convertDistancesToPolygon(currentRoom.wallDistances);
                currentRoom.area = calculatePolygonArea(currentRoom.polygon);
                currentRoom.completed = true;
                currentRoom.confidence = Math.min(95, Object.keys(currentRoom.wallDistances).length * 2);
                
                // ì „ì²´ ë©´ì  ì—…ë°ì´íŠ¸
                building.totalArea = building.rooms.reduce((sum, room) => sum + room.area, 0);
                
                log(`ë°© ${currentRoom.name} ìŠ¤ìº” ì™„ë£Œ - ë©´ì : ${currentRoom.area.toFixed(1)}ã¡`);
                updateStatus(`ë°© ${currentRoom.name} ìŠ¤ìº” ì™„ë£Œ! ë‹¤ìŒ ë°©ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”`, 'success');
                
                // ë‹¤ìŒ ë‹¨ê³„ ì•ˆë‚´
                document.getElementById('guideText').innerHTML = `
                    âœ… <strong>${currentRoom.name} ì™„ë£Œ!</strong><br>
                    ë©´ì : ${currentRoom.area.toFixed(1)}ã¡<br>
                    ë‹¤ìŒ: "ì´ë™ ëª¨ë“œ"ë¡œ ë³€ê²½ í›„ ë‹¤ë¥¸ ë°©ìœ¼ë¡œ ì´ë™
                `;
                
                completeBtn.disabled = false;
            }
            
            updateRoomList();
        }
        
        // ê²½ë¡œ ì—°ê²° ì™„ë£Œ (ë³µë„ ìƒì„± í¬í•¨)
        function completePathConnection() {
            if (currentScanData.pathPoints.length > 10) {
                // ë³µë„ë¥¼ í•˜ë‚˜ì˜ "ê³µê°„"ìœ¼ë¡œ ìƒì„±
                const corridorId = `corridor_${building.connections.length + 1}`;
                const corridorName = `ë³µë„ ${building.connections.length + 1}`;
                
                // ë³µë„ì˜ í‰ê·  í­ê³¼ ê¸¸ì´ ê³„ì‚°
                const avgWidth = currentScanData.pathPoints.reduce((sum, point) => 
                    sum + (point.corridorWidth || 100), 0) / currentScanData.pathPoints.length * 0.05; // ë¯¸í„° ë‹¨ìœ„
                const corridorLength = calculatePathDistance(currentScanData.pathPoints);
                const corridorArea = avgWidth * corridorLength;
                
                // ë³µë„ë¥¼ ê±´ë¬¼ì˜ "ë°©" ëª©ë¡ì— ì¶”ê°€ (ë³µë„ë„ í•˜ë‚˜ì˜ ê³µê°„ìœ¼ë¡œ ì·¨ê¸‰)
                const corridor = {
                    id: corridorId,
                    name: corridorName,
                    type: 'corridor', // ì¼ë°˜ ë°©ê³¼ êµ¬ë¶„
                    wallDistances: {},
                    polygon: generateCorridorPolygon(currentScanData.pathPoints),
                    area: corridorArea,
                    width: avgWidth,
                    length: corridorLength,
                    center: calculatePathCenter(currentScanData.pathPoints),
                    completed: true,
                    confidence: 85,
                    pathPoints: [...currentScanData.pathPoints]
                };
                
                building.rooms.push(corridor);
                building.totalArea += corridorArea;
                
                // ë§ˆì§€ë§‰ ë‘ ë°© ì‚¬ì´ì˜ ì—°ê²° ìƒì„±
                const lastRoom = building.rooms.filter(r => r.type !== 'corridor')[building.rooms.filter(r => r.type !== 'corridor').length - 2];
                const currentRoom = building.rooms.filter(r => r.type !== 'corridor')[building.rooms.filter(r => r.type !== 'corridor').length - 1];
                
                if (lastRoom && currentRoom) {
                    building.connections.push({
                        from: lastRoom.id,
                        to: currentRoom.id,
                        via: corridorId, // ë³µë„ë¥¼ í†µí•œ ì—°ê²°
                        path: [...currentScanData.pathPoints],
                        distance: corridorLength
                    });
                    
                    log(`ì—°ê²° ìƒì„±: ${lastRoom.name} â¡ï¸ ${corridorName} â¡ï¸ ${currentRoom.name}`);
                    log(`ë³µë„ ì •ë³´ - í­: ${avgWidth.toFixed(1)}m, ê¸¸ì´: ${corridorLength.toFixed(1)}m, ë©´ì : ${corridorArea.toFixed(1)}ã¡`);
                }
            }
            
            updateStatus('ë³µë„ ì •ë³´ í¬í•¨ ê²½ë¡œ ì¶”ì  ì™„ë£Œ! ë°© ìŠ¤ìº” ëª¨ë“œë¡œ ë³€ê²½í•˜ì„¸ìš”', 'success');
            updateRoomList();
        }
        
        // ìƒˆ ë°© ì¶”ê°€
        function addNewRoom() {
            switchMode('room');
            log('ìƒˆ ë°© ì¶”ê°€ ì¤€ë¹„');
        }
        
        // ì „ì²´ ê±´ë¬¼ ì™„ë£Œ
        function completeBuilding() {
            log('ì „ì²´ ê±´ë¬¼ ìŠ¤ìº” ì™„ë£Œ');
            updateStatus('ê±´ë¬¼ ì „ì²´ í‰ë©´ë„ë¥¼ ìƒì„±í•©ë‹ˆë‹¤...', 'info');
            
            // ìµœì¢… í‰ë©´ë„ ìƒì„±
            setTimeout(() => {
                generateFinalFloorplan();
                document.getElementById('results').style.display = 'block';
                updateStatus('âœ… ê±´ë¬¼ ì „ì²´ í‰ë©´ë„ ìƒì„± ì™„ë£Œ!', 'success');
            }, 2000);
        }
        
        // ê±°ë¦¬ ë°ì´í„°ë¥¼ ë‹¤ê°í˜•ìœ¼ë¡œ ë³€í™˜
        function convertDistancesToPolygon(wallDistances) {
            const polygon = [];
            const centerX = 0, centerY = 0;
            const scaleFactor = 1.5;
            
            for (let angle = 0; angle < 360; angle += 10) {
                const distance = wallDistances[angle] || interpolateDistance(angle, wallDistances);
                const angleRadians = (angle - 90) * Math.PI / 180;
                
                const x = centerX + distance * scaleFactor * Math.cos(angleRadians);
                const y = centerY + distance * scaleFactor * Math.sin(angleRadians);
                
                polygon.push({x, y, angle});
            }
            
            return polygon;
        }
        
        // ê±°ë¦¬ ë³´ê°„
        function interpolateDistance(targetAngle, distances) {
            const angles = Object.keys(distances).map(a => parseInt(a)).sort((a, b) => a - b);
            if (angles.length === 0) return 100;
            
            // ê°€ì¥ ê°€ê¹Œìš´ ê°ë„ ì°¾ê¸°
            let closest = angles[0];
            let minDiff = Math.abs(targetAngle - closest);
            
            for (let angle of angles) {
                const diff = Math.abs(targetAngle - angle);
                if (diff < minDiff) {
                    minDiff = diff;
                    closest = angle;
                }
            }
            
            return distances[closest];
        }
        
        // ë‹¤ê°í˜• ë©´ì  ê³„ì‚°
        function calculatePolygonArea(polygon) {
            if (polygon.length < 3) return 0;
            
            let area = 0;
            for (let i = 0; i < polygon.length; i++) {
                const j = (i + 1) % polygon.length;
                area += polygon[i].x * polygon[j].y;
                area -= polygon[j].x * polygon[i].y;
            }
            
            area = Math.abs(area) / 2;
            const pixelToMeter = 0.05;
            return area * pixelToMeter * pixelToMeter;
        }
        
        // ë³µë„ ë‹¤ê°í˜• ìƒì„±
        function generateCorridorPolygon(pathPoints) {
            const polygon = [];
            const avgWidth = pathPoints.reduce((sum, point) => 
                sum + (point.corridorWidth || 100), 0) / pathPoints.length;
            
            // ê²½ë¡œë¥¼ ë”°ë¼ ë³µë„ì˜ ì–‘ìª½ ë²½ ìƒì„±
            for (let i = 0; i < pathPoints.length; i++) {
                const point = pathPoints[i];
                const width = (point.corridorWidth || avgWidth) / 2;
                
                // ì§„í–‰ ë°©í–¥ ê³„ì‚°
                let angle = 0;
                if (i < pathPoints.length - 1) {
                    const next = pathPoints[i + 1];
                    angle = Math.atan2(next.y - point.y, next.x - point.x);
                }
                
                // ì–‘ìª½ ë²½ ì  ìƒì„±
                const leftX = point.x + width * Math.cos(angle + Math.PI/2);
                const leftY = point.y + width * Math.sin(angle + Math.PI/2);
                const rightX = point.x + width * Math.cos(angle - Math.PI/2);
                const rightY = point.y + width * Math.sin(angle - Math.PI/2);
                
                polygon.push({x: leftX, y: leftY, side: 'left'});
                polygon.push({x: rightX, y: rightY, side: 'right'});
            }
            
            return polygon;
        }
        
        // ê²½ë¡œ ì¤‘ì‹¬ì  ê³„ì‚°
        function calculatePathCenter(pathPoints) {
            if (pathPoints.length === 0) return {x: 0, y: 0};
            
            const centerX = pathPoints.reduce((sum, point) => sum + point.x, 0) / pathPoints.length;
            const centerY = pathPoints.reduce((sum, point) => sum + point.y, 0) / pathPoints.length;
            
            return {x: centerX, y: centerY};
        }
        
        // ê²½ë¡œ ê±°ë¦¬ ê³„ì‚°
        function calculatePathDistance(pathPoints) {
            let distance = 0;
            for (let i = 1; i < pathPoints.length; i++) {
                const dx = pathPoints[i].x - pathPoints[i-1].x;
                const dy = pathPoints[i].y - pathPoints[i-1].y;
                distance += Math.sqrt(dx * dx + dy * dy);
            }
            return distance * 0.05; // í”½ì…€ì„ ë¯¸í„°ë¡œ ë³€í™˜
        }
        
        // ìµœì¢… í‰ë©´ë„ ìƒì„±
        function generateFinalFloorplan() {
            const ctx = finalMap.getContext('2d');
            ctx.clearRect(0, 0, finalMap.width, finalMap.height);
            
            // ë°°ê²½
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, finalMap.width, finalMap.height);
            
            // ê²©ì
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let x = 0; x <= 400; x += 20) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 400);
                ctx.stroke();
            }
            for (let y = 0; y <= 400; y += 20) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(400, y);
                ctx.stroke();
            }
            
            // ê° ë°© ê·¸ë¦¬ê¸° (ì‹¤ì œ ìœ„ì¹˜ ê¸°ë°˜)
            building.rooms.forEach((room, index) => {
                if (room.type === 'corridor') {
                    // ë³µë„ ê·¸ë¦¬ê¸°
                    if (room.pathPoints && room.pathPoints.length > 1) {
                        // ë³µë„ ì¤‘ì‹¬ì„ 
                        ctx.strokeStyle = '#9e9e9e';
                        ctx.lineWidth = Math.max(4, room.width * 20); // í­ì— ë¹„ë¡€í•œ ì„  ë‘ê»˜
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        
                        ctx.beginPath();
                        ctx.moveTo(room.pathPoints[0].x, room.pathPoints[0].y);
                        for (let i = 1; i < room.pathPoints.length; i++) {
                            ctx.lineTo(room.pathPoints[i].x, room.pathPoints[i].y);
                        }
                        ctx.stroke();
                        
                        // ë³µë„ ì–‘ìª½ ë²½ ê·¸ë¦¬ê¸°
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 2;
                        
                        const leftWall = [];
                        const rightWall = [];
                        
                        for (let i = 0; i < room.pathPoints.length; i++) {
                            const point = room.pathPoints[i];
                            const halfWidth = (room.width * 10) || 15; // ë°˜í­
                            
                            // ì§„í–‰ ë°©í–¥ ê³„ì‚°
                            let angle = 0;
                            if (i < room.pathPoints.length - 1) {
                                const next = room.pathPoints[i + 1];
                                angle = Math.atan2(next.y - point.y, next.x - point.x);
                            } else if (i > 0) {
                                const prev = room.pathPoints[i - 1];
                                angle = Math.atan2(point.y - prev.y, point.x - prev.x);
                            }
                            
                            // ì–‘ìª½ ë²½ ì  ê³„ì‚°
                            const leftX = point.x + halfWidth * Math.cos(angle + Math.PI/2);
                            const leftY = point.y + halfWidth * Math.sin(angle + Math.PI/2);
                            const rightX = point.x + halfWidth * Math.cos(angle - Math.PI/2);
                            const rightY = point.y + halfWidth * Math.sin(angle - Math.PI/2);
                            
                            leftWall.push({x: leftX, y: leftY});
                            rightWall.push({x: rightX, y: rightY});
                        }
                        
                        // ì™¼ìª½ ë²½ ê·¸ë¦¬ê¸°
                        if (leftWall.length > 1) {
                            ctx.beginPath();
                            ctx.moveTo(leftWall[0].x, leftWall[0].y);
                            for (let i = 1; i < leftWall.length; i++) {
                                ctx.lineTo(leftWall[i].x, leftWall[i].y);
                            }
                            ctx.stroke();
                        }
                        
                        // ì˜¤ë¥¸ìª½ ë²½ ê·¸ë¦¬ê¸°
                        if (rightWall.length > 1) {
                            ctx.beginPath();
                            ctx.moveTo(rightWall[0].x, rightWall[0].y);
                            for (let i = 1; i < rightWall.length; i++) {
                                ctx.lineTo(rightWall[i].x, rightWall[i].y);
                            }
                            ctx.stroke();
                        }
                        
                        // ë³µë„ ì •ë³´ í‘œì‹œ
                        const midPoint = room.pathPoints[Math.floor(room.pathPoints.length / 2)];
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(midPoint.x - 25, midPoint.y - 8, 50, 16);
                        ctx.fillStyle = '#666';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${room.name}`, midPoint.x, midPoint.y - 1);
                        ctx.fillText(`${room.width.toFixed(1)}mÃ—${room.length.toFixed(1)}m`, midPoint.x, midPoint.y + 8);
                    }
                } else {
                    // ì¼ë°˜ ë°© ê·¸ë¦¬ê¸°
                    const colors = ['rgba(255, 107, 107, 0.3)', 'rgba(78, 205, 196, 0.3)', 'rgba(69, 183, 209, 0.3)'];
                    const roomIndex = building.rooms.filter(r => r.type !== 'corridor').indexOf(room);
                    const color = colors[roomIndex % colors.length];
                    
                    const roomX = 100 + (roomIndex % 3) * 120;
                    const roomY = 100 + Math.floor(roomIndex / 3) * 120;
                    
                    // ë°© ì˜ì—­
                    ctx.fillStyle = color;
                    ctx.fillRect(roomX - 40, roomY - 30, 80, 60);
                    
                    // ë°© ì™¸ê³½ì„ 
                    ctx.strokeStyle = color.replace('0.3', '1');
                    ctx.lineWidth = 2;
                    ctx.strokeRect(roomX - 40, roomY - 30, 80, 60);
                    
                    // ë°© ì •ë³´
                    ctx.fillStyle = '#333';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(room.name, roomX, roomY - 5);
                    ctx.font = '10px Arial';
                    ctx.fillText(`${room.area.toFixed(1)}ã¡`, roomX, roomY + 10);
                }
            });
            
            // ì—°ê²°ì„ ì€ ë³µë„ë¡œ ëŒ€ì²´ë˜ë¯€ë¡œ ë‹¨ìˆœí•œ ì„ ì€ ê·¸ë¦¬ì§€ ì•ŠìŒ
            // (ë³µë„ê°€ ì‹¤ì œ ì—°ê²° ì—­í• ì„ í•¨)
            
            // ì œëª©
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ğŸ¢ ì™„ì„±ëœ ê±´ë¬¼ í‰ë©´ë„', 200, 30);
            
            // ë²”ë¡€
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('â–  ìŠ¤ìº”ëœ ë°©', 20, 370);
            ctx.fillText('â” ë³µë„/í†µë¡œ (ì‹¤ì œ í­)', 20, 385);
            
            // ê±´ë¬¼ ì •ë³´ í‘œì‹œ
            displayBuildingResults();
        }
        
        // ê±´ë¬¼ ê²°ê³¼ í‘œì‹œ
        function displayBuildingResults() {
            const buildingInfo = document.getElementById('buildingInfo');
            let html = '<h4>ğŸ¢ ì „ì²´ ê±´ë¬¼ ì •ë³´</h4>';
            
            html += `<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin: 15px 0;">`;
            html += `<div style="text-align: center; padding: 15px; background: #e8f5e8; border-radius: 8px;">`;
            html += `<div style="font-size: 24px; font-weight: bold; color: #2e7d32;">${building.rooms.length}</div>`;
            html += `<div style="font-size: 14px;">ì´ ë°© ìˆ˜</div></div>`;
            
            html += `<div style="text-align: center; padding: 15px; background: #e3f2fd; border-radius: 8px;">`;
            html += `<div style="font-size: 24px; font-weight: bold; color: #1976d2;">${building.totalArea.toFixed(1)}ã¡</div>`;
            html += `<div style="font-size: 14px;">ì´ ë©´ì </div></div>`;
            
            html += `<div style="text-align: center; padding: 15px; background: #fff3e0; border-radius: 8px;">`;
            html += `<div style="font-size: 24px; font-weight: bold; color: #f57c00;">${building.connections.length}</div>`;
            html += `<div style="font-size: 14px;">ì—°ê²° í†µë¡œ</div></div>`;
            html += `</div>`;
            
            html += `<h5>ğŸ“‹ ê³µê°„ë³„ ìƒì„¸ ì •ë³´:</h5>`;
            
            // ì¼ë°˜ ë°©ë“¤
            const regularRooms = building.rooms.filter(r => r.type !== 'corridor');
            regularRooms.forEach((room, index) => {
                html += `<div style="padding: 10px; background: #f5f5f5; margin: 5px 0; border-radius: 5px;">`;
                html += `<strong>ğŸ  ${room.name}</strong> - ${room.area.toFixed(1)}ã¡`;
                html += `<br><span style="font-size: 12px; color: #666;">ì‹ ë¢°ë„: ${room.confidence}%</span>`;
                html += `</div>`;
            });
            
            // ë³µë„ë“¤
            const corridors = building.rooms.filter(r => r.type === 'corridor');
            if (corridors.length > 0) {
                html += `<h6 style="margin-top: 15px; color: #666;">ğŸšª ë³µë„ ë° í†µë¡œ:</h6>`;
                corridors.forEach((corridor, index) => {
                    html += `<div style="padding: 10px; background: #f0f0f0; margin: 5px 0; border-radius: 5px;">`;
                    html += `<strong>ğŸšª ${corridor.name}</strong> - ${corridor.area.toFixed(1)}ã¡`;
                    html += `<br><span style="font-size: 12px; color: #666;">`;
                    html += `í­: ${corridor.width.toFixed(1)}m, ê¸¸ì´: ${corridor.length.toFixed(1)}m`;
                    html += `</span>`;
                    html += `</div>`;
                });
            }
            
            if (building.connections.length > 0) {
                html += `<h5>ğŸ”— ì—°ê²° ê´€ê³„:</h5>`;
                building.connections.forEach(conn => {
                    const fromRoom = building.rooms.find(r => r.id === conn.from);
                    const toRoom = building.rooms.find(r => r.id === conn.to);
                    const viaRoom = conn.via ? building.rooms.find(r => r.id === conn.via) : null;
                    
                    if (fromRoom && toRoom) {
                        html += `<div style="padding: 8px; background: #f0f8ff; margin: 5px 0; border-radius: 5px;">`;
                        if (viaRoom) {
                            html += `${fromRoom.name} â†” <strong>${viaRoom.name}</strong> â†” ${toRoom.name}`;
                            html += `<br><span style="font-size: 12px; color: #666;">ì´ ê±°ë¦¬: ${conn.distance.toFixed(1)}m</span>`;
                        } else {
                            html += `${fromRoom.name} â†” ${toRoom.name} (${conn.distance.toFixed(1)}m)`;
                        }
                        html += `</div>`;
                    }
                });
            }
            
            html += `<div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin: 15px 0;">`;
            html += `<strong>ğŸš¨ í™”ì¬í˜„ì¥ í™œìš©:</strong><br>`;
            html += `â€¢ ì „ì²´ ê±´ë¬¼ êµ¬ì¡°ì™€ ë°© ì—°ê²° ê´€ê³„ íŒŒì•… ì™„ë£Œ<br>`;
            html += `â€¢ ê° ë°©ì˜ í¬ê¸°ì™€ ì ‘ê·¼ ê²½ë¡œ í™•ì¸ ê°€ëŠ¥<br>`;
            html += `â€¢ êµ¬ì¡° í™œë™ ë° ëŒ€í”¼ ê³„íš ìˆ˜ë¦½ì— í™œìš©<br>`;
            html += `â€¢ ì¶”ê°€ ì¸µì´ ìˆë‹¤ë©´ ë™ì¼í•œ ë°©ë²•ìœ¼ë¡œ ìŠ¤ìº” ê°€ëŠ¥`;
            html += `</div>`;
            
            buildingInfo.innerHTML = html;
        }
        
        // ë””ë²„ê·¸ í† ê¸€
        function toggleDebug() {
            debugInfo.classList.toggle('show-debug');
        }
        
        // ì˜¤ë¥˜ ì²˜ë¦¬
        window.onerror = function(message, source, lineno, colno, error) {
            log(`âŒ ì˜¤ë¥˜: ${message} (${source}:${lineno})`);
            return false;
        };
        
        window.addEventListener('unhandledrejection', function(event) {
            log(`âŒ Promise ì˜¤ë¥˜: ${event.reason}`);
        });
        
        log('ë‹¤ì¤‘ë°© í†µí•© í‰ë©´ë„ ìƒì„±ê¸° ì´ˆê¸°í™” ì™„ë£Œ');
    </script>
</body>
</html>
