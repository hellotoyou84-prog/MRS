<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🚨 다중방 통합 평면도 생성기</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 450px;
            margin: 0 auto;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        h1 {
            text-align: center;
            color: #d32f2f;
            margin-bottom: 10px;
            font-size: 20px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-bottom: 20px;
        }
        
        .status {
            padding: 12px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
            font-size: 14px;
        }
        
        .status.info { background: #e3f2fd; color: #1976d2; border: 2px solid #2196f3; }
        .status.success { background: #e8f5e8; color: #2e7d32; border: 2px solid #4caf50; }
        .status.error { background: #ffebee; color: #c62828; border: 2px solid #f44336; }
        .status.warning { background: #fff3e0; color: #f57c00; border: 2px solid #ff9800; }
        
        video, canvas {
            width: 100%;
            border-radius: 8px;
            margin: 10px 0;
            background: #000;
        }
        
        button {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary { background: #2196f3; color: white; }
        .btn-primary:hover { background: #1976d2; }
        .btn-success { background: #4caf50; color: white; }
        .btn-success:hover { background: #388e3c; }
        .btn-danger { background: #f44336; color: white; }
        .btn-danger:hover { background: #d32f2f; }
        .btn-warning { background: #ff9800; color: white; }
        .btn-warning:hover { background: #f57c00; }
        .btn-secondary { background: #9c27b0; color: white; }
        .btn-secondary:hover { background: #7b1fa2; }
        
        button:disabled { background: #ccc; cursor: not-allowed; }
        
        .mode-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #dee2e6;
        }
        
        .mode-card {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid #dee2e6;
        }
        
        .mode-card.active {
            border-color: #2196f3;
            background: #e3f2fd;
        }
        
        .mode-card:hover {
            background: #f0f0f0;
        }
        
        .guide-box {
            background: #f0f4ff;
            border: 2px solid #2196f3;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-size: 14px;
        }
        
        .guide-box h4 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }
        
        .room-list {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .room-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }
        
        .room-item.current {
            border-color: #4caf50;
            background: #e8f5e8;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin: 15px 0;
        }
        
        .metric {
            text-align: center;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 6px;
            font-size: 12px;
        }
        
        .metric-value {
            font-size: 16px;
            font-weight: bold;
            color: #2196f3;
        }
        
        .path-indicator {
            text-align: center;
            padding: 15px;
            margin: 15px 0;
            background: #fff3e0;
            border-radius: 8px;
            border: 2px solid #ff9800;
            display: none;
        }
        
        .path-indicator.show { display: block; }
        
        .building-map {
            border: 2px solid #4caf50;
            background: #f8fff8;
            margin: 15px 0;
        }
        
        .debug-info {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 11px;
            max-height: 150px;
            overflow-y: auto;
            display: none;
        }
        
        .show-debug { display: block; }
        
        .emergency-tip {
            background: #ffebee;
            border: 2px solid #f44336;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
            color: #c62828;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🚨 다중방 통합 평면도 생성기</h1>
        <div class="subtitle">방별 스캔 + 이동 경로 추적 🏠➡️🏠</div>
        
        <div class="mode-selector">
            <div class="mode-card active" id="roomMode">
                <h4>🔄 방 스캔 모드</h4>
                <div style="font-size: 12px;">방 중앙에서 360도 회전</div>
            </div>
            <div class="mode-card" id="pathMode">
                <h4>🚶 이동 모드</h4>
                <div style="font-size: 12px;">방 사이 경로 추적</div>
            </div>
        </div>
        
        <div class="guide-box">
            <h4 id="guideTitle">🎯 방 스캔 모드</h4>
            <div id="guideText">
                1️⃣ 첫 번째 방 중앙에 서기<br>
                2️⃣ "방 스캔" 버튼으로 360도 회전<br>
                3️⃣ "이동 모드"로 변경 후 다음 방으로<br>
                4️⃣ 반복하여 모든 방 스캔 완료!
            </div>
        </div>
        
        <div class="emergency-tip">
            🚨 <strong>화재현장 활용:</strong> 각 방 + 복도/계단 연결 관계 파악으로 전체 구조 매핑
        </div>
        
        <div id="status" class="status info">시스템 초기화 중...</div>
        
        <div class="room-list">
            <h4>📋 스캔된 방 목록</h4>
            <div id="roomListContainer">
                <div style="text-align: center; color: #666; font-size: 12px;">
                    아직 스캔된 방이 없습니다
                </div>
            </div>
            <button id="newRoomBtn" class="btn-secondary" disabled>➕ 새 방 추가</button>
        </div>
        
        <video id="video" autoplay playsinline muted style="display: none;"></video>
        <canvas id="processCanvas" style="display: none;"></canvas>
        
        <div class="path-indicator" id="pathIndicator">
            <div><strong>🚶 방 사이 이동 중...</strong></div>
            <div>현재 경로를 추적하고 있습니다</div>
            <div style="font-size: 12px; margin-top: 5px;">다음 방에 도착하면 "방 스캔 모드"로 변경하세요</div>
        </div>
        
        <canvas id="buildingMap" class="building-map" width="400" height="400" style="display: none;"></canvas>
        
        <div class="metrics" id="metrics" style="display: none;">
            <div class="metric">
                <div class="metric-value" id="roomCount">0</div>
                <div>스캔된 방</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="connectionCount">0</div>
                <div>연결 경로</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="totalArea">0㎡</div>
                <div>총 면적</div>
            </div>
        </div>
        
        <div class="controls">
            <button id="startBtn" class="btn-primary">📹 카메라 시작</button>
            <button id="scanBtn" class="btn-success" disabled>🔄 스캔 시작</button>
            <button id="stopBtn" class="btn-danger" disabled>⏹️ 중지</button>
            <button id="completeBtn" class="btn-warning" disabled>✅ 전체 완료</button>
        </div>
        
        <button id="debugBtn" class="btn-primary" style="font-size: 12px;">🔧 디버그 정보</button>
        
        <div class="debug-info" id="debugInfo">
            === 다중방 스캔 시스템 시작 ===<br>
        </div>
        
        <div id="results" style="display: none;">
            <h3 style="color: #2196f3; margin: 20px 0 10px 0;">🏢 전체 건물 평면도</h3>
            <canvas id="finalMap" width="400" height="400" style="border: 2px solid #2196f3;"></canvas>
            <div id="buildingInfo" style="margin-top: 10px;"></div>
        </div>
    </div>

    <!-- OpenCV.js 로드 -->
    <script async src="https://docs.opencv.org/4.5.2/opencv.js" type="text/javascript"></script>
    
    <script>
        // 전역 변수
        let video, processCanvas, buildingMap, finalMap;
        let startBtn, scanBtn, stopBtn, completeBtn, debugBtn, newRoomBtn;
        let roomMode, pathMode, status, debugInfo, metrics, pathIndicator;
        let stream = null;
        let isScanning = false;
        let currentMode = 'room'; // 'room' 또는 'path'
        let frameCount = 0;
        
        // 다중방 데이터 구조
        let building = {
            rooms: [],           // 각 방의 정보
            connections: [],     // 방 사이 연결 정보
            currentRoom: null,   // 현재 스캔 중인 방
            totalArea: 0,        // 전체 면적
            centerPoint: {x: 200, y: 200} // 건물 중심점
        };
        
        // 현재 스캔 데이터
        let currentScanData = {
            roomId: null,
            wallDistances: {},
            position: {x: 0, y: 0},
            rotation: 0,
            pathPoints: []
        };
        
        // 센서 데이터
        let gyroData = {x: 0, y: 0, z: 0};
        let previousPosition = null;
        
        // OpenCV 관련
        let detector = null;
        
        // 로그 함수
        function log(message) {
            console.log(message);
            const now = new Date().toLocaleTimeString();
            if (debugInfo) {
                debugInfo.innerHTML += `[${now}] ${message}<br>`;
                debugInfo.scrollTop = debugInfo.scrollHeight;
            }
        }
        
        // 상태 업데이트
        function updateStatus(message, type = 'info') {
            console.log(`상태: ${message}`);
            if (status) {
                status.textContent = message;
                status.className = `status ${type}`;
            }
            log(`상태: ${message}`);
        }
        
        // 모드 변경
        function switchMode(newMode) {
            currentMode = newMode;
            
            // UI 업데이트
            roomMode.classList.toggle('active', newMode === 'room');
            pathMode.classList.toggle('active', newMode === 'path');
            pathIndicator.classList.toggle('show', newMode === 'path');
            
            if (newMode === 'room') {
                document.getElementById('guideTitle').textContent = '🎯 방 스캔 모드';
                document.getElementById('guideText').innerHTML = `
                    🔄 현재: 방 ${building.rooms.length + 1} 스캔<br>
                    • 방 중앙에 서서 360도 회전<br>
                    • 완료 후 "이동 모드"로 변경<br>
                    • 다음 방으로 이동하세요
                `;
                scanBtn.textContent = '🔄 방 스캔 시작';
                
            } else { // path 모드
                document.getElementById('guideTitle').textContent = '🚶 이동 모드 (복도 감지)';
                document.getElementById('guideText').innerHTML = `
                    🚶 다음 방으로 이동 중...<br>
                    • 복도 양쪽 벽까지의 거리 자동 측정<br>
                    • 복도 폭과 모양이 실시간 감지됩니다<br>
                    • 다음 방 중앙에 도착하면 "방 스캔 모드"로 변경
                `;
                scanBtn.textContent = '🚶 복도 추적 시작';
            }
            
            log(`모드 변경: ${newMode}`);
        }
        
        // 방 목록 업데이트
        function updateRoomList() {
            const container = document.getElementById('roomListContainer');
            
            if (building.rooms.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; color: #666; font-size: 12px;">
                        아직 스캔된 방이 없습니다
                    </div>
                `;
            } else {
                let html = '';
                building.rooms.forEach((room, index) => {
                    const isCurrent = room.id === building.currentRoom;
                    html += `
                        <div class="room-item ${isCurrent ? 'current' : ''}">
                            <div>
                                <strong>${room.name}</strong><br>
                                <span style="font-size: 12px; color: #666;">
                                    ${room.area.toFixed(1)}㎡ | ${room.confidence}% 신뢰도
                                </span>
                            </div>
                            <div style="font-size: 12px; color: ${room.completed ? '#4caf50' : '#ff9800'};">
                                ${room.completed ? '✅ 완료' : '🔄 진행중'}
                            </div>
                        </div>
                    `;
                });
                container.innerHTML = html;
            }
            
            // 메트릭 업데이트
            if (document.getElementById('roomCount')) {
                document.getElementById('roomCount').textContent = building.rooms.length;
                document.getElementById('connectionCount').textContent = building.connections.length;
                document.getElementById('totalArea').textContent = building.totalArea.toFixed(1) + '㎡';
            }
        }
        
        // 센서 초기화
        function initializeSensors() {
            if (typeof DeviceMotionEvent !== 'undefined') {
                window.addEventListener('devicemotion', function(event) {
                    if (event.rotationRate && isScanning) {
                        gyroData = event.rotationRate;
                        
                        if (currentMode === 'room') {
                            // 방 스캔 모드: 회전 추적
                            if (gyroData.z !== null) {
                                currentScanData.rotation += gyroData.z * 0.1;
                                currentScanData.rotation = ((currentScanData.rotation % 360) + 360) % 360;
                            }
                        } else {
                            // 이동 모드: 위치 추적
                            updatePositionFromSensors(event);
                        }
                    }
                });
                log('센서 초기화 완료');
            }
            
            // iOS 권한 요청
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission().then(response => {
                    log(`센서 권한: ${response}`);
                });
            }
        }
        
        // 센서에서 위치 업데이트 (이동 모드용)
        function updatePositionFromSensors(event) {
            if (event.acceleration) {
                const accel = event.acceleration;
                const speed = Math.sqrt(accel.x**2 + accel.y**2 + accel.z**2);
                
                if (speed > 0.5) { // 움직임 감지
                    // 간단한 위치 추정 (실제로는 더 복잡한 계산 필요)
                    const movement = speed * 0.1;
                    const angle = currentScanData.rotation * Math.PI / 180;
                    
                    currentScanData.position.x += movement * Math.cos(angle);
                    currentScanData.position.y += movement * Math.sin(angle);
                    
                    // 경로 점 추가
                    currentScanData.pathPoints.push({
                        x: currentScanData.position.x,
                        y: currentScanData.position.y,
                        timestamp: Date.now()
                    });
                }
            }
        }
        
        // OpenCV 초기화 대기
        function waitForOpenCV() {
            return new Promise((resolve) => {
                if (typeof cv !== 'undefined') {
                    resolve();
                } else {
                    const checkInterval = setInterval(() => {
                        if (typeof cv !== 'undefined') {
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 100);
                }
            });
        }
        
        // DOM 로드 완료 시 초기화
        document.addEventListener('DOMContentLoaded', async function() {
            log('다중방 통합 시스템 초기화 시작');
            
            // 요소들 가져오기
            video = document.getElementById('video');
            processCanvas = document.getElementById('processCanvas');
            buildingMap = document.getElementById('buildingMap');
            finalMap = document.getElementById('finalMap');
            
            startBtn = document.getElementById('startBtn');
            scanBtn = document.getElementById('scanBtn');
            stopBtn = document.getElementById('stopBtn');
            completeBtn = document.getElementById('completeBtn');
            debugBtn = document.getElementById('debugBtn');
            newRoomBtn = document.getElementById('newRoomBtn');
            
            roomMode = document.getElementById('roomMode');
            pathMode = document.getElementById('pathMode');
            status = document.getElementById('status');
            debugInfo = document.getElementById('debugInfo');
            metrics = document.getElementById('metrics');
            pathIndicator = document.getElementById('pathIndicator');
            
            // 이벤트 리스너 등록
            startBtn.addEventListener('click', startCamera);
            scanBtn.addEventListener('click', startScan);
            stopBtn.addEventListener('click', stopScan);
            completeBtn.addEventListener('click', completeBuilding);
            debugBtn.addEventListener('click', toggleDebug);
            newRoomBtn.addEventListener('click', addNewRoom);
            
            roomMode.addEventListener('click', () => switchMode('room'));
            pathMode.addEventListener('click', () => switchMode('path'));
            
            log('이벤트 리스너 등록 완료');
            
            // 초기 UI 설정
            updateRoomList();
            
            // 센서 초기화
            initializeSensors();
            
            // OpenCV 로딩 대기
            updateStatus('OpenCV.js 로딩 중...', 'info');
            await waitForOpenCV();
            
            // OpenCV 초기화
            initializeOpenCV();
            
            updateStatus('준비 완료! 첫 번째 방에서 카메라를 시작하세요', 'success');
        });
        
        // OpenCV 초기화
        function initializeOpenCV() {
            try {
                detector = new cv.ORB(500);
                processCanvas.width = 640;
                processCanvas.height = 480;
                log('OpenCV 다중방 스캔용 초기화 완료');
            } catch (error) {
                log(`OpenCV 초기화 오류: ${error.message}`);
                updateStatus('OpenCV 초기화 실패', 'error');
            }
        }
        
        // 카메라 시작
        async function startCamera() {
            log('카메라 시작 시도...');
            updateStatus('카메라 권한 요청 중...', 'info');
            
            try {
                const constraints = {
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                video.style.display = 'block';
                
                video.onloadedmetadata = function() {
                    log(`비디오 해상도: ${video.videoWidth}x${video.videoHeight}`);
                    updateStatus('카메라 준비 완료! 스캔을 시작하세요', 'success');
                    startBtn.disabled = true;
                    scanBtn.disabled = false;
                    newRoomBtn.disabled = false;
                    buildingMap.style.display = 'block';
                    metrics.style.display = 'grid';
                };
                
            } catch (error) {
                log(`카메라 오류: ${error.message}`);
                updateStatus(`카메라 오류: ${error.message}`, 'error');
                
                if (error.name === 'NotAllowedError') {
                    alert('카메라 권한을 허용해주세요!');
                }
            }
        }
        
        // 스캔 시작
        function startScan() {
            if (!stream) {
                alert('먼저 카메라를 시작해주세요');
                return;
            }
            
            log(`${currentMode} 모드 스캔 시작`);
            isScanning = true;
            
            // UI 업데이트
            scanBtn.disabled = true;
            stopBtn.disabled = false;
            
            if (currentMode === 'room') {
                startRoomScan();
            } else {
                startPathTracking();
            }
            
            // 실시간 처리 시작
            processFrames();
        }
        
        // 방 스캔 시작
        function startRoomScan() {
            // 새 방 생성
            const roomId = `room_${building.rooms.length + 1}`;
            const newRoom = {
                id: roomId,
                name: `방 ${building.rooms.length + 1}`,
                wallDistances: {},
                polygon: [],
                area: 0,
                center: {...currentScanData.position},
                completed: false,
                confidence: 0
            };
            
            building.rooms.push(newRoom);
            building.currentRoom = roomId;
            
            // 스캔 데이터 초기화
            currentScanData.roomId = roomId;
            currentScanData.wallDistances = {};
            currentScanData.rotation = 0;
            
            updateStatus(`🔄 방 ${building.rooms.length} 스캔 중...`, 'warning');
            updateRoomList();
            
            log(`새 방 생성: ${roomId}`);
        }
        
        // 경로 추적 시작
        function startPathTracking() {
            currentScanData.pathPoints = [];
            previousPosition = {...currentScanData.position};
            
            updateStatus('🚶 방 사이 이동 경로 추적 중...', 'warning');
            log('경로 추적 시작');
        }
        
        // 프레임 처리
        async function processFrames() {
            if (!isScanning) return;
            
            try {
                const ctx = processCanvas.getContext('2d');
                ctx.drawImage(video, 0, 0, processCanvas.width, processCanvas.height);
                
                frameCount++;
                
                if (currentMode === 'room') {
                    await processRoomScan();
                } else {
                    await processPathTracking();
                }
                
                // 건물 맵 그리기
                drawBuildingMap();
                
                // 다음 프레임 처리
                setTimeout(processFrames, 200);
                
            } catch (error) {
                log(`프레임 처리 오류: ${error.message}`);
                setTimeout(processFrames, 200);
            }
        }
        
        // 방 스캔 처리
        async function processRoomScan() {
            try {
                // OpenCV 매트릭스 생성
                const src = cv.imread(processCanvas);
                const gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // 엣지 검출
                const edges = new cv.Mat();
                cv.Canny(gray, edges, 50, 150);
                
                // 현재 방향에서 벽까지 거리 측정
                const centerX = processCanvas.width / 2;
                const centerY = processCanvas.height / 2;
                
                for (let offsetAngle = -30; offsetAngle <= 30; offsetAngle += 10) {
                    const rayAngle = currentScanData.rotation + offsetAngle;
                    const distance = castRayForWall(edges, centerX, centerY, rayAngle);
                    
                    if (distance > 0) {
                        currentScanData.wallDistances[Math.round(rayAngle) % 360] = distance;
                        
                        // 현재 방 데이터 업데이트
                        const currentRoom = building.rooms.find(r => r.id === building.currentRoom);
                        if (currentRoom) {
                            currentRoom.wallDistances[Math.round(rayAngle) % 360] = distance;
                        }
                    }
                }
                
                // 메모리 정리
                src.delete();
                gray.delete();
                edges.delete();
                
            } catch (error) {
                log(`방 스캔 처리 오류: ${error.message}`);
            }
        }
        
        // 경로 추적 처리 (복도 모양 감지 포함)
        async function processPathTracking() {
            try {
                // 시각적 특징점으로 이동 감지
                const src = cv.imread(processCanvas);
                const gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // 엣지 검출로 복도 벽면 감지
                const edges = new cv.Mat();
                cv.Canny(gray, edges, 50, 150);
                
                // 복도 양옆 벽까지의 거리 측정
                const centerX = processCanvas.width / 2;
                const centerY = processCanvas.height / 2;
                
                const leftDistance = castRayForWall(edges, centerX, centerY, currentScanData.rotation - 90); // 왼쪽
                const rightDistance = castRayForWall(edges, centerX, centerY, currentScanData.rotation + 90); // 오른쪽
                const frontDistance = castRayForWall(edges, centerX, centerY, currentScanData.rotation); // 앞쪽
                
                // 특징점 검출로 이동량 추정
                const keypoints = new cv.KeyPointVector();
                const descriptors = new cv.Mat();
                detector.detectAndCompute(gray, new cv.Mat(), keypoints, descriptors);
                
                if (previousPosition && keypoints.size() > 10) {
                    // 간단한 이동 추정 (실제로는 더 복잡한 계산)
                    const movement = estimateMovementFromFeatures(keypoints);
                    
                    currentScanData.position.x += movement.dx;
                    currentScanData.position.y += movement.dy;
                    
                    // 복도 정보를 포함한 경로 점 추가
                    currentScanData.pathPoints.push({
                        x: currentScanData.position.x,
                        y: currentScanData.position.y,
                        leftWall: leftDistance,
                        rightWall: rightDistance,
                        frontWall: frontDistance,
                        corridorWidth: leftDistance + rightDistance,
                        timestamp: Date.now()
                    });
                    
                    log(`복도 감지 - 폭: ${(leftDistance + rightDistance) * 0.05}m, 좌벽: ${leftDistance * 0.05}m, 우벽: ${rightDistance * 0.05}m`);
                }
                
                // 메모리 정리
                src.delete();
                gray.delete();
                edges.delete();
                keypoints.delete();
                descriptors.delete();
                
            } catch (error) {
                log(`경로 추적 처리 오류: ${error.message}`);
            }
        }
        
        // Ray casting으로 벽 거리 측정
        function castRayForWall(edges, startX, startY, angleDegrees) {
            const angleRadians = angleDegrees * Math.PI / 180;
            const maxDistance = 200;
            
            for (let distance = 20; distance < maxDistance; distance += 5) {
                const x = Math.round(startX + distance * Math.cos(angleRadians));
                const y = Math.round(startY + distance * Math.sin(angleRadians));
                
                if (x < 0 || x >= edges.cols || y < 0 || y >= edges.rows) {
                    return distance;
                }
                
                const pixelValue = edges.ucharPtr(y, x)[0];
                if (pixelValue > 100) {
                    return distance;
                }
            }
            
            return maxDistance;
        }
        
        // 특징점에서 이동 추정
        function estimateMovementFromFeatures(keypoints) {
            // 간단한 이동 추정 (실제로는 optical flow 등 사용)
            return {
                dx: (Math.random() - 0.5) * 2, // 임시 구현
                dy: (Math.random() - 0.5) * 2
            };
        }
        
        // 건물 맵 그리기
        function drawBuildingMap() {
            const ctx = buildingMap.getContext('2d');
            ctx.clearRect(0, 0, buildingMap.width, buildingMap.height);
            
            // 배경 격자
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let x = 0; x <= 400; x += 20) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 400);
                ctx.stroke();
            }
            for (let y = 0; y <= 400; y += 20) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(400, y);
                ctx.stroke();
            }
            
            // 스캔된 방들 그리기
            building.rooms.forEach((room, index) => {
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f39c12', '#9b59b6'];
                const color = colors[index % colors.length];
                
                // 방 다각형 (간단한 원으로 표시)
                const roomX = 100 + (index % 3) * 120;
                const roomY = 100 + Math.floor(index / 3) * 120;
                
                ctx.fillStyle = color + '40';
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(roomX, roomY, 40, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // 방 번호
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(room.name, roomX, roomY + 5);
                
                // 완료 표시
                if (room.completed) {
                    ctx.fillStyle = '#4caf50';
                    ctx.font = '16px Arial';
                    ctx.fillText('✅', roomX + 30, roomY - 30);
                }
                
                // 현재 스캔 중 표시
                if (room.id === building.currentRoom) {
                    ctx.strokeStyle = '#f44336';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(roomX, roomY, 45, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
            
            // 연결선 그리기
            building.connections.forEach(connection => {
                const room1Index = building.rooms.findIndex(r => r.id === connection.from);
                const room2Index = building.rooms.findIndex(r => r.id === connection.to);
                
                if (room1Index >= 0 && room2Index >= 0) {
                    const x1 = 100 + (room1Index % 3) * 120;
                    const y1 = 100 + Math.floor(room1Index / 3) * 120;
                    const x2 = 100 + (room2Index % 3) * 120;
                    const y2 = 100 + Math.floor(room2Index / 3) * 120;
                    
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
            
            // 제목
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('🏢 건물 전체 구조', 200, 25);
        }
        
        // 스캔 중지
        function stopScan() {
            log('스캔 중지');
            isScanning = false;
            
            scanBtn.disabled = false;
            stopBtn.disabled = true;
            
            if (currentMode === 'room') {
                completeCurrentRoom();
            } else {
                completePathConnection();
            }
        }
        
        // 현재 방 스캔 완료
        function completeCurrentRoom() {
            const currentRoom = building.rooms.find(r => r.id === building.currentRoom);
            if (currentRoom) {
                // 방 다각형 생성
                currentRoom.polygon = convertDistancesToPolygon(currentRoom.wallDistances);
                currentRoom.area = calculatePolygonArea(currentRoom.polygon);
                currentRoom.completed = true;
                currentRoom.confidence = Math.min(95, Object.keys(currentRoom.wallDistances).length * 2);
                
                // 전체 면적 업데이트
                building.totalArea = building.rooms.reduce((sum, room) => sum + room.area, 0);
                
                log(`방 ${currentRoom.name} 스캔 완료 - 면적: ${currentRoom.area.toFixed(1)}㎡`);
                updateStatus(`방 ${currentRoom.name} 스캔 완료! 다음 방으로 이동하세요`, 'success');
                
                // 다음 단계 안내
                document.getElementById('guideText').innerHTML = `
                    ✅ <strong>${currentRoom.name} 완료!</strong><br>
                    면적: ${currentRoom.area.toFixed(1)}㎡<br>
                    다음: "이동 모드"로 변경 후 다른 방으로 이동
                `;
                
                completeBtn.disabled = false;
            }
            
            updateRoomList();
        }
        
        // 경로 연결 완료 (복도 생성 포함)
        function completePathConnection() {
            if (currentScanData.pathPoints.length > 10) {
                // 복도를 하나의 "공간"으로 생성
                const corridorId = `corridor_${building.connections.length + 1}`;
                const corridorName = `복도 ${building.connections.length + 1}`;
                
                // 복도의 평균 폭과 길이 계산
                const avgWidth = currentScanData.pathPoints.reduce((sum, point) => 
                    sum + (point.corridorWidth || 100), 0) / currentScanData.pathPoints.length * 0.05; // 미터 단위
                const corridorLength = calculatePathDistance(currentScanData.pathPoints);
                const corridorArea = avgWidth * corridorLength;
                
                // 복도를 건물의 "방" 목록에 추가 (복도도 하나의 공간으로 취급)
                const corridor = {
                    id: corridorId,
                    name: corridorName,
                    type: 'corridor', // 일반 방과 구분
                    wallDistances: {},
                    polygon: generateCorridorPolygon(currentScanData.pathPoints),
                    area: corridorArea,
                    width: avgWidth,
                    length: corridorLength,
                    center: calculatePathCenter(currentScanData.pathPoints),
                    completed: true,
                    confidence: 85,
                    pathPoints: [...currentScanData.pathPoints]
                };
                
                building.rooms.push(corridor);
                building.totalArea += corridorArea;
                
                // 마지막 두 방 사이의 연결 생성
                const lastRoom = building.rooms.filter(r => r.type !== 'corridor')[building.rooms.filter(r => r.type !== 'corridor').length - 2];
                const currentRoom = building.rooms.filter(r => r.type !== 'corridor')[building.rooms.filter(r => r.type !== 'corridor').length - 1];
                
                if (lastRoom && currentRoom) {
                    building.connections.push({
                        from: lastRoom.id,
                        to: currentRoom.id,
                        via: corridorId, // 복도를 통한 연결
                        path: [...currentScanData.pathPoints],
                        distance: corridorLength
                    });
                    
                    log(`연결 생성: ${lastRoom.name} ➡️ ${corridorName} ➡️ ${currentRoom.name}`);
                    log(`복도 정보 - 폭: ${avgWidth.toFixed(1)}m, 길이: ${corridorLength.toFixed(1)}m, 면적: ${corridorArea.toFixed(1)}㎡`);
                }
            }
            
            updateStatus('복도 정보 포함 경로 추적 완료! 방 스캔 모드로 변경하세요', 'success');
            updateRoomList();
        }
        
        // 새 방 추가
        function addNewRoom() {
            switchMode('room');
            log('새 방 추가 준비');
        }
        
        // 전체 건물 완료
        function completeBuilding() {
            log('전체 건물 스캔 완료');
            updateStatus('건물 전체 평면도를 생성합니다...', 'info');
            
            // 최종 평면도 생성
            setTimeout(() => {
                generateFinalFloorplan();
                document.getElementById('results').style.display = 'block';
                updateStatus('✅ 건물 전체 평면도 생성 완료!', 'success');
            }, 2000);
        }
        
        // 거리 데이터를 다각형으로 변환
        function convertDistancesToPolygon(wallDistances) {
            const polygon = [];
            const centerX = 0, centerY = 0;
            const scaleFactor = 1.5;
            
            for (let angle = 0; angle < 360; angle += 10) {
                const distance = wallDistances[angle] || interpolateDistance(angle, wallDistances);
                const angleRadians = (angle - 90) * Math.PI / 180;
                
                const x = centerX + distance * scaleFactor * Math.cos(angleRadians);
                const y = centerY + distance * scaleFactor * Math.sin(angleRadians);
                
                polygon.push({x, y, angle});
            }
            
            return polygon;
        }
        
        // 거리 보간
        function interpolateDistance(targetAngle, distances) {
            const angles = Object.keys(distances).map(a => parseInt(a)).sort((a, b) => a - b);
            if (angles.length === 0) return 100;
            
            // 가장 가까운 각도 찾기
            let closest = angles[0];
            let minDiff = Math.abs(targetAngle - closest);
            
            for (let angle of angles) {
                const diff = Math.abs(targetAngle - angle);
                if (diff < minDiff) {
                    minDiff = diff;
                    closest = angle;
                }
            }
            
            return distances[closest];
        }
        
        // 다각형 면적 계산
        function calculatePolygonArea(polygon) {
            if (polygon.length < 3) return 0;
            
            let area = 0;
            for (let i = 0; i < polygon.length; i++) {
                const j = (i + 1) % polygon.length;
                area += polygon[i].x * polygon[j].y;
                area -= polygon[j].x * polygon[i].y;
            }
            
            area = Math.abs(area) / 2;
            const pixelToMeter = 0.05;
            return area * pixelToMeter * pixelToMeter;
        }
        
        // 복도 다각형 생성
        function generateCorridorPolygon(pathPoints) {
            const polygon = [];
            const avgWidth = pathPoints.reduce((sum, point) => 
                sum + (point.corridorWidth || 100), 0) / pathPoints.length;
            
            // 경로를 따라 복도의 양쪽 벽 생성
            for (let i = 0; i < pathPoints.length; i++) {
                const point = pathPoints[i];
                const width = (point.corridorWidth || avgWidth) / 2;
                
                // 진행 방향 계산
                let angle = 0;
                if (i < pathPoints.length - 1) {
                    const next = pathPoints[i + 1];
                    angle = Math.atan2(next.y - point.y, next.x - point.x);
                }
                
                // 양쪽 벽 점 생성
                const leftX = point.x + width * Math.cos(angle + Math.PI/2);
                const leftY = point.y + width * Math.sin(angle + Math.PI/2);
                const rightX = point.x + width * Math.cos(angle - Math.PI/2);
                const rightY = point.y + width * Math.sin(angle - Math.PI/2);
                
                polygon.push({x: leftX, y: leftY, side: 'left'});
                polygon.push({x: rightX, y: rightY, side: 'right'});
            }
            
            return polygon;
        }
        
        // 경로 중심점 계산
        function calculatePathCenter(pathPoints) {
            if (pathPoints.length === 0) return {x: 0, y: 0};
            
            const centerX = pathPoints.reduce((sum, point) => sum + point.x, 0) / pathPoints.length;
            const centerY = pathPoints.reduce((sum, point) => sum + point.y, 0) / pathPoints.length;
            
            return {x: centerX, y: centerY};
        }
        
        // 경로 거리 계산
        function calculatePathDistance(pathPoints) {
            let distance = 0;
            for (let i = 1; i < pathPoints.length; i++) {
                const dx = pathPoints[i].x - pathPoints[i-1].x;
                const dy = pathPoints[i].y - pathPoints[i-1].y;
                distance += Math.sqrt(dx * dx + dy * dy);
            }
            return distance * 0.05; // 픽셀을 미터로 변환
        }
        
        // 최종 평면도 생성
        function generateFinalFloorplan() {
            const ctx = finalMap.getContext('2d');
            ctx.clearRect(0, 0, finalMap.width, finalMap.height);
            
            // 배경
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, finalMap.width, finalMap.height);
            
            // 격자
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let x = 0; x <= 400; x += 20) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 400);
                ctx.stroke();
            }
            for (let y = 0; y <= 400; y += 20) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(400, y);
                ctx.stroke();
            }
            
            // 각 방 그리기 (실제 위치 기반)
            building.rooms.forEach((room, index) => {
                if (room.type === 'corridor') {
                    // 복도 그리기
                    if (room.pathPoints && room.pathPoints.length > 1) {
                        // 복도 중심선
                        ctx.strokeStyle = '#9e9e9e';
                        ctx.lineWidth = Math.max(4, room.width * 20); // 폭에 비례한 선 두께
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        
                        ctx.beginPath();
                        ctx.moveTo(room.pathPoints[0].x, room.pathPoints[0].y);
                        for (let i = 1; i < room.pathPoints.length; i++) {
                            ctx.lineTo(room.pathPoints[i].x, room.pathPoints[i].y);
                        }
                        ctx.stroke();
                        
                        // 복도 양쪽 벽 그리기
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 2;
                        
                        const leftWall = [];
                        const rightWall = [];
                        
                        for (let i = 0; i < room.pathPoints.length; i++) {
                            const point = room.pathPoints[i];
                            const halfWidth = (room.width * 10) || 15; // 반폭
                            
                            // 진행 방향 계산
                            let angle = 0;
                            if (i < room.pathPoints.length - 1) {
                                const next = room.pathPoints[i + 1];
                                angle = Math.atan2(next.y - point.y, next.x - point.x);
                            } else if (i > 0) {
                                const prev = room.pathPoints[i - 1];
                                angle = Math.atan2(point.y - prev.y, point.x - prev.x);
                            }
                            
                            // 양쪽 벽 점 계산
                            const leftX = point.x + halfWidth * Math.cos(angle + Math.PI/2);
                            const leftY = point.y + halfWidth * Math.sin(angle + Math.PI/2);
                            const rightX = point.x + halfWidth * Math.cos(angle - Math.PI/2);
                            const rightY = point.y + halfWidth * Math.sin(angle - Math.PI/2);
                            
                            leftWall.push({x: leftX, y: leftY});
                            rightWall.push({x: rightX, y: rightY});
                        }
                        
                        // 왼쪽 벽 그리기
                        if (leftWall.length > 1) {
                            ctx.beginPath();
                            ctx.moveTo(leftWall[0].x, leftWall[0].y);
                            for (let i = 1; i < leftWall.length; i++) {
                                ctx.lineTo(leftWall[i].x, leftWall[i].y);
                            }
                            ctx.stroke();
                        }
                        
                        // 오른쪽 벽 그리기
                        if (rightWall.length > 1) {
                            ctx.beginPath();
                            ctx.moveTo(rightWall[0].x, rightWall[0].y);
                            for (let i = 1; i < rightWall.length; i++) {
                                ctx.lineTo(rightWall[i].x, rightWall[i].y);
                            }
                            ctx.stroke();
                        }
                        
                        // 복도 정보 표시
                        const midPoint = room.pathPoints[Math.floor(room.pathPoints.length / 2)];
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(midPoint.x - 25, midPoint.y - 8, 50, 16);
                        ctx.fillStyle = '#666';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${room.name}`, midPoint.x, midPoint.y - 1);
                        ctx.fillText(`${room.width.toFixed(1)}m×${room.length.toFixed(1)}m`, midPoint.x, midPoint.y + 8);
                    }
                } else {
                    // 일반 방 그리기
                    const colors = ['rgba(255, 107, 107, 0.3)', 'rgba(78, 205, 196, 0.3)', 'rgba(69, 183, 209, 0.3)'];
                    const roomIndex = building.rooms.filter(r => r.type !== 'corridor').indexOf(room);
                    const color = colors[roomIndex % colors.length];
                    
                    const roomX = 100 + (roomIndex % 3) * 120;
                    const roomY = 100 + Math.floor(roomIndex / 3) * 120;
                    
                    // 방 영역
                    ctx.fillStyle = color;
                    ctx.fillRect(roomX - 40, roomY - 30, 80, 60);
                    
                    // 방 외곽선
                    ctx.strokeStyle = color.replace('0.3', '1');
                    ctx.lineWidth = 2;
                    ctx.strokeRect(roomX - 40, roomY - 30, 80, 60);
                    
                    // 방 정보
                    ctx.fillStyle = '#333';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(room.name, roomX, roomY - 5);
                    ctx.font = '10px Arial';
                    ctx.fillText(`${room.area.toFixed(1)}㎡`, roomX, roomY + 10);
                }
            });
            
            // 연결선은 복도로 대체되므로 단순한 선은 그리지 않음
            // (복도가 실제 연결 역할을 함)
            
            // 제목
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('🏢 완성된 건물 평면도', 200, 30);
            
            // 범례
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('■ 스캔된 방', 20, 370);
            ctx.fillText('━ 복도/통로 (실제 폭)', 20, 385);
            
            // 건물 정보 표시
            displayBuildingResults();
        }
        
        // 건물 결과 표시
        function displayBuildingResults() {
            const buildingInfo = document.getElementById('buildingInfo');
            let html = '<h4>🏢 전체 건물 정보</h4>';
            
            html += `<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin: 15px 0;">`;
            html += `<div style="text-align: center; padding: 15px; background: #e8f5e8; border-radius: 8px;">`;
            html += `<div style="font-size: 24px; font-weight: bold; color: #2e7d32;">${building.rooms.length}</div>`;
            html += `<div style="font-size: 14px;">총 방 수</div></div>`;
            
            html += `<div style="text-align: center; padding: 15px; background: #e3f2fd; border-radius: 8px;">`;
            html += `<div style="font-size: 24px; font-weight: bold; color: #1976d2;">${building.totalArea.toFixed(1)}㎡</div>`;
            html += `<div style="font-size: 14px;">총 면적</div></div>`;
            
            html += `<div style="text-align: center; padding: 15px; background: #fff3e0; border-radius: 8px;">`;
            html += `<div style="font-size: 24px; font-weight: bold; color: #f57c00;">${building.connections.length}</div>`;
            html += `<div style="font-size: 14px;">연결 통로</div></div>`;
            html += `</div>`;
            
            html += `<h5>📋 공간별 상세 정보:</h5>`;
            
            // 일반 방들
            const regularRooms = building.rooms.filter(r => r.type !== 'corridor');
            regularRooms.forEach((room, index) => {
                html += `<div style="padding: 10px; background: #f5f5f5; margin: 5px 0; border-radius: 5px;">`;
                html += `<strong>🏠 ${room.name}</strong> - ${room.area.toFixed(1)}㎡`;
                html += `<br><span style="font-size: 12px; color: #666;">신뢰도: ${room.confidence}%</span>`;
                html += `</div>`;
            });
            
            // 복도들
            const corridors = building.rooms.filter(r => r.type === 'corridor');
            if (corridors.length > 0) {
                html += `<h6 style="margin-top: 15px; color: #666;">🚪 복도 및 통로:</h6>`;
                corridors.forEach((corridor, index) => {
                    html += `<div style="padding: 10px; background: #f0f0f0; margin: 5px 0; border-radius: 5px;">`;
                    html += `<strong>🚪 ${corridor.name}</strong> - ${corridor.area.toFixed(1)}㎡`;
                    html += `<br><span style="font-size: 12px; color: #666;">`;
                    html += `폭: ${corridor.width.toFixed(1)}m, 길이: ${corridor.length.toFixed(1)}m`;
                    html += `</span>`;
                    html += `</div>`;
                });
            }
            
            if (building.connections.length > 0) {
                html += `<h5>🔗 연결 관계:</h5>`;
                building.connections.forEach(conn => {
                    const fromRoom = building.rooms.find(r => r.id === conn.from);
                    const toRoom = building.rooms.find(r => r.id === conn.to);
                    const viaRoom = conn.via ? building.rooms.find(r => r.id === conn.via) : null;
                    
                    if (fromRoom && toRoom) {
                        html += `<div style="padding: 8px; background: #f0f8ff; margin: 5px 0; border-radius: 5px;">`;
                        if (viaRoom) {
                            html += `${fromRoom.name} ↔ <strong>${viaRoom.name}</strong> ↔ ${toRoom.name}`;
                            html += `<br><span style="font-size: 12px; color: #666;">총 거리: ${conn.distance.toFixed(1)}m</span>`;
                        } else {
                            html += `${fromRoom.name} ↔ ${toRoom.name} (${conn.distance.toFixed(1)}m)`;
                        }
                        html += `</div>`;
                    }
                });
            }
            
            html += `<div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin: 15px 0;">`;
            html += `<strong>🚨 화재현장 활용:</strong><br>`;
            html += `• 전체 건물 구조와 방 연결 관계 파악 완료<br>`;
            html += `• 각 방의 크기와 접근 경로 확인 가능<br>`;
            html += `• 구조 활동 및 대피 계획 수립에 활용<br>`;
            html += `• 추가 층이 있다면 동일한 방법으로 스캔 가능`;
            html += `</div>`;
            
            buildingInfo.innerHTML = html;
        }
        
        // 디버그 토글
        function toggleDebug() {
            debugInfo.classList.toggle('show-debug');
        }
        
        // 오류 처리
        window.onerror = function(message, source, lineno, colno, error) {
            log(`❌ 오류: ${message} (${source}:${lineno})`);
            return false;
        };
        
        window.addEventListener('unhandledrejection', function(event) {
            log(`❌ Promise 오류: ${event.reason}`);
        });
        
        log('다중방 통합 평면도 생성기 초기화 완료');
    </script>
</body>
</html>
