<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸš¨ ê³ ì •ë°€ í™”ì¬í˜„ì¥ í‰ë©´ë„ ìƒì„±ê¸°</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 450px;
            margin: 0 auto;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        h1 {
            text-align: center;
            color: #d32f2f;
            margin-bottom: 10px;
            font-size: 20px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-bottom: 20px;
        }
        
        .status {
            padding: 12px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
            font-size: 14px;
        }
        
        .status.info { background: #e3f2fd; color: #1976d2; border: 2px solid #2196f3; }
        .status.success { background: #e8f5e8; color: #2e7d32; border: 2px solid #4caf50; }
        .status.error { background: #ffebee; color: #c62828; border: 2px solid #f44336; }
        .status.warning { background: #fff3e0; color: #f57c00; border: 2px solid #ff9800; }
        
        video, canvas {
            width: 100%;
            border-radius: 8px;
            margin: 10px 0;
            background: #000;
        }
        
        button {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary { background: #2196f3; color: white; }
        .btn-primary:hover { background: #1976d2; }
        .btn-success { background: #4caf50; color: white; }
        .btn-success:hover { background: #388e3c; }
        .btn-danger { background: #f44336; color: white; }
        .btn-danger:hover { background: #d32f2f; }
        .btn-warning { background: #ff9800; color: white; }
        .btn-warning:hover { background: #f57c00; }
        
        button:disabled { background: #ccc; cursor: not-allowed; }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin: 15px 0;
        }
        
        .metric {
            text-align: center;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 6px;
            font-size: 12px;
        }
        
        .metric-value {
            font-size: 16px;
            font-weight: bold;
            color: #2196f3;
        }
        
        .guide-box {
            background: #f0f4ff;
            border: 2px solid #2196f3;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-size: 13px;
        }
        
        .guide-box h4 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }
        
        .calibration {
            background: #fff3e0;
            border: 2px solid #ff9800;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .sensor-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }
        
        .sensor-value {
            text-align: center;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 5px;
            font-size: 11px;
        }
        
        .correction-tools {
            display: none;
            background: #e8f5e8;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .correction-tools.show { display: block; }
        
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .debug-info {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 11px;
            max-height: 150px;
            overflow-y: auto;
            display: none;
        }
        
        .show-debug { display: block; }
        
        #mapCanvas {
            border: 2px solid #ddd;
            background: #f8f9fa;
        }
        
        .quality-indicator {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .quality-excellent { background: #e8f5e8; color: #2e7d32; }
        .quality-good { background: #fff3e0; color: #f57c00; }
        .quality-poor { background: #ffebee; color: #c62828; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš¨ ê³ ì •ë°€ í™”ì¬í˜„ì¥ í‰ë©´ë„ ìƒì„±ê¸°</h1>
        <div class="subtitle">AI + ì„¼ì„œ ìœµí•© SLAM</div>
        
        <div class="guide-box">
            <h4>ğŸ“± ì •í™•ë„ í–¥ìƒ ê°€ì´ë“œ</h4>
            <div id="guideText">
                1ï¸âƒ£ íœ´ëŒ€í°ì„ ìˆ˜í‰ìœ¼ë¡œ ë“¤ê³  ì²œì²œíˆ ì´ë™<br>
                2ï¸âƒ£ ë²½ë©´ì„ ë”°ë¼ ì¼ì •í•œ ì†ë„ë¡œ ì´ë™<br>
                3ï¸âƒ£ ì¡°ëª…ì´ ì¶©ë¶„í•œ ê³³ì—ì„œ ì´¬ì˜<br>
                4ï¸âƒ£ ê¸‰ê²©í•œ íšŒì „ì´ë‚˜ ë¹ ë¥¸ ì›€ì§ì„ í”¼í•˜ê¸°
            </div>
        </div>
        
        <div class="calibration">
            <h4>ğŸ”§ ì‹œìŠ¤í…œ ìº˜ë¦¬ë¸Œë ˆì´ì…˜</h4>
            <button id="calibrateBtn" class="btn-warning">ğŸ“ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹œì‘</button>
            <div id="calibrationStatus">ìº˜ë¦¬ë¸Œë ˆì´ì…˜ í•„ìš”</div>
        </div>
        
        <div id="status" class="status info">ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...</div>
        
        <div id="qualityIndicator" class="quality-indicator quality-poor" style="display: none;">
            ì´¬ì˜ í’ˆì§ˆ: ë³´í†µ
        </div>
        
        <video id="video" autoplay playsinline muted style="display: none;"></video>
        <canvas id="processCanvas" style="display: none;"></canvas>
        <canvas id="mapCanvas" width="400" height="300" style="display: none;"></canvas>
        
        <div class="metrics" id="metrics" style="display: none;">
            <div class="metric">
                <div class="metric-value" id="frameCount">0</div>
                <div>ì²˜ë¦¬ëœ í”„ë ˆì„</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="featureCount">0</div>
                <div>íŠ¹ì§•ì  ìˆ˜</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="confidence">0%</div>
                <div>ì‹ ë¢°ë„</div>
            </div>
        </div>
        
        <div class="sensor-info" id="sensorInfo" style="display: none;">
            <div class="sensor-value">
                <div>ìì´ë¡œ: <span id="gyroValue">0.0</span></div>
            </div>
            <div class="sensor-value">
                <div>ê°€ì†ë„: <span id="accelValue">0.0</span></div>
            </div>
            <div class="sensor-value">
                <div>ì†ë„: <span id="speedValue">0.0</span></div>
            </div>
            <div class="sensor-value">
                <div>ìŠ¤ì¼€ì¼: <span id="scaleValue">1.0</span></div>
            </div>
        </div>
        
        <div class="controls">
            <button id="startBtn" class="btn-primary">ğŸ“¹ ì¹´ë©”ë¼ ì‹œì‘</button>
            <button id="scanBtn" class="btn-success" disabled>ğŸ” ìŠ¤ìº” ì‹œì‘</button>
            <button id="stopBtn" class="btn-danger" disabled>â¹ï¸ ì¤‘ì§€</button>
            <button id="saveBtn" class="btn-warning" disabled>ğŸ’¾ ê²°ê³¼ ì €ì¥</button>
        </div>
        
        <button id="correctBtn" class="btn-primary" disabled>ğŸ”§ ìˆ˜ë™ ë³´ì •</button>
        
        <div class="correction-tools" id="correctionTools">
            <h4>ğŸ¯ ìˆ˜ë™ ë³´ì • ë„êµ¬</h4>
            <label>ìŠ¤ì¼€ì¼ ì¡°ì •:</label>
            <input type="range" id="scaleSlider" min="0.5" max="2.0" step="0.1" value="1.0">
            <span id="scaleDisplay">1.0x</span><br>
            
            <label>íšŒì „ ë³´ì •:</label>
            <input type="range" id="rotationSlider" min="-180" max="180" step="5" value="0">
            <span id="rotationDisplay">0Â°</span><br>
            
            <button id="resetCorrection" class="btn-primary">ì´ˆê¸°í™”</button>
            <button id="applyCorrection" class="btn-success">ì ìš©</button>
        </div>
        
        <button id="debugBtn" class="btn-primary" style="font-size: 12px;">ğŸ”§ ë””ë²„ê·¸ ì •ë³´ í† ê¸€</button>
        
        <div class="debug-info" id="debugInfo">
            === ì‹œìŠ¤í…œ ì´ˆê¸°í™” ===<br>
        </div>
        
        <div id="results" style="display: none;">
            <h3 style="color: #2196f3; margin: 20px 0 10px 0;">ğŸ“ ìƒì„±ëœ í‰ë©´ë„</h3>
            <canvas id="finalMap" width="400" height="300" style="border: 2px solid #2196f3;"></canvas>
            <div id="roomInfo" style="margin-top: 10px;"></div>
        </div>
    </div>

    <!-- OpenCV.js ë¡œë“œ -->
    <script async src="https://docs.opencv.org/4.5.2/opencv.js" type="text/javascript"></script>
    
    <script>
        // ì „ì—­ ë³€ìˆ˜
        let video, processCanvas, mapCanvas, finalMap;
        let startBtn, scanBtn, stopBtn, saveBtn, debugBtn, correctBtn, calibrateBtn;
        let status, debugInfo, metrics, sensorInfo, qualityIndicator, correctionTools;
        let stream = null;
        let isScanning = false;
        let isCalibrated = false;
        let frameCount = 0;
        let featureCount = 0;
        let confidence = 0;
        
        // ì„¼ì„œ ë°ì´í„°
        let gyroData = {x: 0, y: 0, z: 0};
        let accelData = {x: 0, y: 0, z: 0};
        let currentSpeed = 0;
        let deviceScale = 1.0;
        
        // SLAM ê´€ë ¨ ë³€ìˆ˜ (ê°œì„ ëœ ë²„ì „)
        let previousFrame = null;
        let currentPosition = {x: 200, y: 150, angle: 0};
        let trajectory = [];
        let mapPoints = [];
        let walls = [];
        let rooms = [];
        let keyframes = []; // í‚¤í”„ë ˆì„ ì €ì¥
        
        // ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë°ì´í„°
        let calibrationData = {
            pixelPerMeter: 100, // ê¸°ë³¸ê°’
            deviceOrientation: 0,
            cameraHeight: 1.5 // ë¯¸í„°
        };
        
        // í’ˆì§ˆ í‰ê°€ ë³€ìˆ˜
        let motionBlur = 0;
        let lightingQuality = 0;
        let featureQuality = 0;
        
        // OpenCV ë§¤íŠ¸ë¦­ìŠ¤
        let src, gray, prevGray;
        let detector = null;
        let descriptorMatcher = null;
        
        // ë¡œê·¸ í•¨ìˆ˜
        function log(message) {
            console.log(message);
            const now = new Date().toLocaleTimeString();
            if (debugInfo) {
                debugInfo.innerHTML += `[${now}] ${message}<br>`;
                debugInfo.scrollTop = debugInfo.scrollHeight;
            }
        }
        
        // ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateStatus(message, type = 'info') {
            console.log(`ìƒíƒœ: ${message}`);
            if (status) {
                status.textContent = message;
                status.className = `status ${type}`;
            }
            log(`ìƒíƒœ: ${message}`);
        }
        
        // ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
        function updateMetrics() {
            if (document.getElementById('frameCount')) {
                document.getElementById('frameCount').textContent = frameCount;
                document.getElementById('featureCount').textContent = featureCount;
                document.getElementById('confidence').textContent = Math.round(confidence) + '%';
            }
        }
        
        // ì„¼ì„œ ì •ë³´ ì—…ë°ì´íŠ¸
        function updateSensorInfo() {
            if (document.getElementById('gyroValue')) {
                document.getElementById('gyroValue').textContent = gyroData.z.toFixed(2);
                document.getElementById('accelValue').textContent = Math.sqrt(accelData.x**2 + accelData.y**2 + accelData.z**2).toFixed(2);
                document.getElementById('speedValue').textContent = currentSpeed.toFixed(2);
                document.getElementById('scaleValue').textContent = deviceScale.toFixed(2);
            }
        }
        
        // í’ˆì§ˆ ì§€í‘œ ì—…ë°ì´íŠ¸
        function updateQualityIndicator() {
            if (!qualityIndicator) return;
            
            const overallQuality = (featureQuality + lightingQuality + (100 - motionBlur)) / 3;
            
            qualityIndicator.style.display = 'block';
            if (overallQuality > 80) {
                qualityIndicator.className = 'quality-indicator quality-excellent';
                qualityIndicator.textContent = 'ğŸ“¸ ì´¬ì˜ í’ˆì§ˆ: ìš°ìˆ˜';
            } else if (overallQuality > 60) {
                qualityIndicator.className = 'quality-indicator quality-good';
                qualityIndicator.textContent = 'ğŸ“¸ ì´¬ì˜ í’ˆì§ˆ: ë³´í†µ';
            } else {
                qualityIndicator.className = 'quality-indicator quality-poor';
                qualityIndicator.textContent = 'ğŸ“¸ ì´¬ì˜ í’ˆì§ˆ: ë‚®ìŒ - ì²œì²œíˆ ì´ë™í•˜ì„¸ìš”';
            }
        }
        
        // ì„¼ì„œ ì´ˆê¸°í™”
        function initializeSensors() {
            if (typeof DeviceMotionEvent !== 'undefined') {
                window.addEventListener('devicemotion', function(event) {
                    if (event.rotationRate) {
                        gyroData = event.rotationRate;
                    }
                    if (event.acceleration) {
                        accelData = event.acceleration;
                        
                        // ì†ë„ ì¶”ì • (ê°„ë‹¨í•œ ì ë¶„)
                        const totalAccel = Math.sqrt(accelData.x**2 + accelData.y**2 + accelData.z**2);
                        currentSpeed = currentSpeed * 0.9 + totalAccel * 0.1; // í‰í™œí™”
                    }
                    updateSensorInfo();
                });
                log('ì„¼ì„œ ì´ˆê¸°í™” ì™„ë£Œ');
            } else {
                log('ì„¼ì„œ ì§€ì› ì•ˆë¨');
            }
            
            // iOS ê¶Œí•œ ìš”ì²­
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission().then(response => {
                    log(`ì„¼ì„œ ê¶Œí•œ: ${response}`);
                });
            }
        }
        
        // OpenCV ì´ˆê¸°í™” ëŒ€ê¸°
        function waitForOpenCV() {
            return new Promise((resolve) => {
                if (typeof cv !== 'undefined') {
                    log('OpenCV.js ì´ë¯¸ ë¡œë“œë¨');
                    resolve();
                } else {
                    log('OpenCV.js ë¡œë”© ëŒ€ê¸° ì¤‘...');
                    const checkInterval = setInterval(() => {
                        if (typeof cv !== 'undefined') {
                            clearInterval(checkInterval);
                            log('OpenCV.js ë¡œë“œ ì™„ë£Œ');
                            resolve();
                        }
                    }, 100);
                }
            });
        }
        
        // DOM ë¡œë“œ ì™„ë£Œ ì‹œ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', async function() {
            log('DOM ì´ˆê¸°í™” ì‹œì‘');
            
            // ìš”ì†Œë“¤ ê°€ì ¸ì˜¤ê¸°
            video = document.getElementById('video');
            processCanvas = document.getElementById('processCanvas');
            mapCanvas = document.getElementById('mapCanvas');
            finalMap = document.getElementById('finalMap');
            
            startBtn = document.getElementById('startBtn');
            scanBtn = document.getElementById('scanBtn');
            stopBtn = document.getElementById('stopBtn');
            saveBtn = document.getElementById('saveBtn');
            debugBtn = document.getElementById('debugBtn');
            correctBtn = document.getElementById('correctBtn');
            calibrateBtn = document.getElementById('calibrateBtn');
            
            status = document.getElementById('status');
            debugInfo = document.getElementById('debugInfo');
            metrics = document.getElementById('metrics');
            sensorInfo = document.getElementById('sensorInfo');
            qualityIndicator = document.getElementById('qualityIndicator');
            correctionTools = document.getElementById('correctionTools');
            
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
            startBtn.addEventListener('click', startCamera);
            scanBtn.addEventListener('click', startScanning);
            stopBtn.addEventListener('click', stopScanning);
            saveBtn.addEventListener('click', saveResults);
            debugBtn.addEventListener('click', toggleDebug);
            correctBtn.addEventListener('click', toggleCorrection);
            calibrateBtn.addEventListener('click', startCalibration);
            
            // ë³´ì • ë„êµ¬ ì´ë²¤íŠ¸
            document.getElementById('scaleSlider').addEventListener('input', updateScaleDisplay);
            document.getElementById('rotationSlider').addEventListener('input', updateRotationDisplay);
            document.getElementById('resetCorrection').addEventListener('click', resetCorrection);
            document.getElementById('applyCorrection').addEventListener('click', applyCorrection);
            
            log('ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ ì™„ë£Œ');
            
            // ì„¼ì„œ ì´ˆê¸°í™”
            initializeSensors();
            
            // OpenCV ë¡œë”© ëŒ€ê¸°
            updateStatus('OpenCV.js ë¡œë”© ì¤‘...', 'info');
            await waitForOpenCV();
            
            // OpenCV ì´ˆê¸°í™”
            initializeOpenCV();
            
            updateStatus('ì¤€ë¹„ ì™„ë£Œ! ë¨¼ì € ìº˜ë¦¬ë¸Œë ˆì´ì…˜ì„ ì§„í–‰í•˜ì„¸ìš”', 'warning');
        });
        
        // OpenCV ì´ˆê¸°í™” (ê°œì„ ëœ ë²„ì „)
        function initializeOpenCV() {
            try {
                // ë” ì •í™•í•œ ORB ê²€ì¶œê¸°
                detector = new cv.ORB(1000, 1.2, 8, 31, 0, 2, cv.ORB_HARRIS_SCORE, 31, 20);
                
                // FLANN ë§¤ì²˜ (ë” ì •í™•í•œ ë§¤ì¹­)
                descriptorMatcher = new cv.BFMatcher(cv.NORM_HAMMING, true);
                
                log('ê³ ê¸‰ ORB ê²€ì¶œê¸° + BF ë§¤ì²˜ ì´ˆê¸°í™” ì™„ë£Œ');
                
                // ì²˜ë¦¬ìš© ìº”ë²„ìŠ¤ ì„¤ì • (í•´ìƒë„ í–¥ìƒ)
                processCanvas.width = 640;
                processCanvas.height = 480;
                
                // ë§µ ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
                clearMap();
                
                log('OpenCV ê³ ê¸‰ ì´ˆê¸°í™” ì™„ë£Œ');
            } catch (error) {
                log(`OpenCV ì´ˆê¸°í™” ì˜¤ë¥˜: ${error.message}`);
                updateStatus('OpenCV ì´ˆê¸°í™” ì‹¤íŒ¨', 'error');
            }
        }
        
        // ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹œì‘
        async function startCalibration() {
            updateStatus('ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹œì‘...', 'info');
            log('=== ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹œì‘ ===');
            
            if (!stream) {
                alert('ë¨¼ì € ì¹´ë©”ë¼ë¥¼ ì‹œì‘í•´ì£¼ì„¸ìš”');
                return;
            }
            
            document.getElementById('guideText').innerHTML = `
                ğŸ¯ <strong>ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë‹¨ê³„:</strong><br>
                1ï¸âƒ£ íœ´ëŒ€í°ì„ ë°”ë‹¥ì—ì„œ 1.5m ë†’ì´ë¡œ ë“¤ê¸°<br>
                2ï¸âƒ£ ì•Œë ¤ì§„ ê±°ë¦¬(ì˜ˆ: 1m íƒ€ì¼)ë¥¼ ì´¬ì˜<br>
                3ï¸âƒ£ ì²œì²œíˆ ì§ì„ ìœ¼ë¡œ 2-3m ì´ë™<br>
                4ï¸âƒ£ 10ì´ˆê°„ ìœ ì§€í•˜ë©´ ìë™ ì™„ë£Œ
            `;
            
            // ìº˜ë¦¬ë¸Œë ˆì´ì…˜ í”„ë¡œì„¸ìŠ¤
            let calibFrames = 0;
            const calibrationInterval = setInterval(() => {
                if (!isScanning) {
                    calibFrames++;
                    
                    if (calibFrames >= 100) { // 10ì´ˆ (10 FPS)
                        clearInterval(calibrationInterval);
                        completeCalibration();
                    }
                    
                    document.getElementById('calibrationStatus').textContent = 
                        `ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì§„í–‰: ${Math.round(calibFrames/10)}ì´ˆ`;
                }
            }, 100);
        }
        
        // ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ
        function completeCalibration() {
            // ì´ë™ ê±°ë¦¬ ê¸°ë°˜ìœ¼ë¡œ ìŠ¤ì¼€ì¼ ê³„ì‚°
            if (trajectory.length > 50) {
                let totalPixelDistance = 0;
                for (let i = 1; i < trajectory.length; i++) {
                    const dx = trajectory[i].x - trajectory[i-1].x;
                    const dy = trajectory[i].y - trajectory[i-1].y;
                    totalPixelDistance += Math.sqrt(dx * dx + dy * dy);
                }
                
                const assumedRealDistance = 2.0; // 2ë¯¸í„° ì´ë™ ê°€ì •
                calibrationData.pixelPerMeter = totalPixelDistance / assumedRealDistance;
                deviceScale = calibrationData.pixelPerMeter / 100; // ì •ê·œí™”
            }
            
            isCalibrated = true;
            updateStatus('ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ!', 'success');
            document.getElementById('calibrationStatus').textContent = 'ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ âœ…';
            
            document.getElementById('guideText').innerHTML = `
                âœ… <strong>ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ!</strong><br>
                ì´ì œ ì •í™•í•œ ìŠ¤ìº”ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.<br>
                ìŠ¤ì¼€ì¼ íŒ©í„°: ${deviceScale.toFixed(2)}x
            `;
            
            log(`ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ - ìŠ¤ì¼€ì¼: ${deviceScale.toFixed(2)}`);
        }
        
        // ì¹´ë©”ë¼ ì‹œì‘
        async function startCamera() {
            log('ì¹´ë©”ë¼ ì‹œì‘ ì‹œë„...');
            updateStatus('ì¹´ë©”ë¼ ê¶Œí•œ ìš”ì²­ ì¤‘...', 'info');
            
            try {
                const constraints = {
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280, max: 1280 },
                        height: { ideal: 720, max: 720 }
                    }
                };
                
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                video.style.display = 'block';
                
                video.onloadedmetadata = function() {
                    log(`ë¹„ë””ì˜¤ í•´ìƒë„: ${video.videoWidth}x${video.videoHeight}`);
                    updateStatus('ì¹´ë©”ë¼ ì¤€ë¹„ ì™„ë£Œ!', 'success');
                    startBtn.disabled = true;
                    scanBtn.disabled = false;
                    
                    // ì„¼ì„œ ì •ë³´ í‘œì‹œ
                    sensorInfo.style.display = 'grid';
                };
                
            } catch (error) {
                log(`ì¹´ë©”ë¼ ì˜¤ë¥˜: ${error.message}`);
                updateStatus(`ì¹´ë©”ë¼ ì˜¤ë¥˜: ${error.message}`, 'error');
                
                if (error.name === 'NotAllowedError') {
                    alert('ì¹´ë©”ë¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”!');
                }
            }
        }
        
        // ìŠ¤ìº” ì‹œì‘
        function startScanning() {
            if (!stream) {
                alert('ë¨¼ì € ì¹´ë©”ë¼ë¥¼ ì‹œì‘í•´ì£¼ì„¸ìš”');
                return;
            }
            
            if (!isCalibrated) {
                alert('ë¨¼ì € ìº˜ë¦¬ë¸Œë ˆì´ì…˜ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”');
                return;
            }
            
            log('ê³ ì •ë°€ SLAM ìŠ¤ìº” ì‹œì‘');
            isScanning = true;
            
            // UI ì—…ë°ì´íŠ¸
            scanBtn.disabled = true;
            stopBtn.disabled = false;
            correctBtn.disabled = false;
            mapCanvas.style.display = 'block';
            metrics.style.display = 'grid';
            updateStatus('ğŸ” ê³ ì •ë°€ ìŠ¤ìº” ì¤‘...', 'warning');
            
            // ì´ˆê¸°í™”
            frameCount = 0;
            featureCount = 0;
            confidence = 0;
            trajectory = [];
            mapPoints = [];
            walls = [];
            keyframes = [];
            
            currentPosition = {x: 200, y: 150, angle: 0};
            trajectory.push({...currentPosition});
            
            // ì‹¤ì‹œê°„ ì²˜ë¦¬ ì‹œì‘ (í–¥ìƒëœ ë²„ì „)
            processFramesAdvanced();
        }
        
        // ê³ ê¸‰ í”„ë ˆì„ ì²˜ë¦¬
        async function processFramesAdvanced() {
            if (!isScanning) return;
            
            try {
                // ë¹„ë””ì˜¤ í”„ë ˆì„ì„ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸° (í•´ìƒë„ í–¥ìƒ)
                const ctx = processCanvas.getContext('2d');
                ctx.drawImage(video, 0, 0, processCanvas.width, processCanvas.height);
                
                // í’ˆì§ˆ í‰ê°€
                evaluateFrameQuality(ctx);
                
                // OpenCV ë§¤íŠ¸ë¦­ìŠ¤ ìƒì„±
                src = cv.imread(processCanvas);
                gray = new cv.Mat();
                
                // ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // ë…¸ì´ì¦ˆ ì œê±° (í’ˆì§ˆ í–¥ìƒ)
                const blurred = new cv.Mat();
                cv.GaussianBlur(gray, blurred, new cv.Size(3, 3), 0, 0, cv.BORDER_DEFAULT);
                
                frameCount++;
                
                if (previousFrame === null) {
                    // ì²« ë²ˆì§¸ í”„ë ˆì„
                    previousFrame = blurred.clone();
                    log('ì²« ë²ˆì§¸ í”„ë ˆì„ ì²˜ë¦¬ ì™„ë£Œ (ê³ í•´ìƒë„)');
                } else {
                    // ê³ ê¸‰ SLAM ì²˜ë¦¬
                    await performAdvancedSLAM(blurred);
                }
                
                // í‚¤í”„ë ˆì„ ì €ì¥ (ì¼ì • ê°„ê²©ìœ¼ë¡œ)
                if (frameCount % 30 === 0) {
                    saveKeyframe(blurred.clone());
                }
                
                // ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
                updateMetrics();
                updateQualityIndicator();
                
                // ë§µ ê·¸ë¦¬ê¸°
                drawAdvancedMap();
                
                // ë©”ëª¨ë¦¬ ì •ë¦¬
                src.delete();
                blurred.delete();
                if (gray !== previousFrame) {
                    gray.delete();
                }
                
                // ë‹¤ìŒ í”„ë ˆì„ ì²˜ë¦¬ (í”„ë ˆì„ë ˆì´íŠ¸ ìµœì í™”)
                setTimeout(processFramesAdvanced, confidence > 70 ? 50 : 100);
                
            } catch (error) {
                log(`í”„ë ˆì„ ì²˜ë¦¬ ì˜¤ë¥˜: ${error.message}`);
                setTimeout(processFramesAdvanced, 200);
            }
        }
        
        // í”„ë ˆì„ í’ˆì§ˆ í‰ê°€
        function evaluateFrameQuality(ctx) {
            const imageData = ctx.getImageData(0, 0, processCanvas.width, processCanvas.height);
            const data = imageData.data;
            
            // ì¡°ëª… í’ˆì§ˆ í‰ê°€
            let brightness = 0;
            for (let i = 0; i < data.length; i += 4) {
                brightness += (data[i] + data[i+1] + data[i+2]) / 3;
            }
            brightness /= (data.length / 4);
            lightingQuality = Math.max(0, 100 - Math.abs(brightness - 128));
            
            // ëª¨ì…˜ ë¸”ëŸ¬ ì¶”ì • (ì„¼ì„œ ê¸°ë°˜)
            motionBlur = Math.min(100, currentSpeed * 10);
            
            // íŠ¹ì§•ì  í’ˆì§ˆ
            featureQuality = Math.min(100, featureCount / 5);
        }
        
        // í‚¤í”„ë ˆì„ ì €ì¥
        function saveKeyframe(frame) {
            keyframes.push({
                frame: frame,
                position: {...currentPosition},
                timestamp: Date.now()
            });
            
            // í‚¤í”„ë ˆì„ ìˆ˜ ì œí•œ
            if (keyframes.length > 20) {
                keyframes[0].frame.delete();
                keyframes.shift();
            }
            
            log(`í‚¤í”„ë ˆì„ ì €ì¥ë¨ (ì´ ${keyframes.length}ê°œ)`);
        }
        
        // ê³ ê¸‰ SLAM ì•Œê³ ë¦¬ì¦˜
        async function performAdvancedSLAM(currentFrame) {
            try {
                // 1. íŠ¹ì§•ì  ê²€ì¶œ (í–¥ìƒëœ íŒŒë¼ë¯¸í„°)
                const keypoints1 = new cv.KeyPointVector();
                const descriptors1 = new cv.Mat();
                const keypoints2 = new cv.KeyPointVector();
                const descriptors2 = new cv.Mat();
                
                detector.detectAndCompute(previousFrame, new cv.Mat(), keypoints1, descriptors1);
                detector.detectAndCompute(currentFrame, new cv.Mat(), keypoints2, descriptors2);
                
                featureCount = keypoints2.size();
                
                if (keypoints1.size() > 20 && keypoints2.size() > 20 && descriptors1.rows > 0 && descriptors2.rows > 0) {
                    // 2. íŠ¹ì§•ì  ë§¤ì¹­ (í–¥ìƒëœ ë§¤ì¹­)
                    const matches = matchFeaturesAdvanced(descriptors1, descriptors2);
                    
                    if (matches.size() > 10) {
                        // 3. RANSACìœ¼ë¡œ ì•„ì›ƒë¼ì´ì–´ ì œê±°
                        const goodMatches = filterMatchesRANSAC(keypoints1, keypoints2, matches);
                        
                        if (goodMatches.length > 8) {
                            // 4. ì„¼ì„œ ìœµí•© ì›€ì§ì„ ì¶”ì •
                            const motion = estimateMotionWithSensors(keypoints1, keypoints2, goodMatches);
                            
                            // 5. ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ìŠ¤ì¼€ì¼ ì ìš©)
                            updatePositionAdvanced(motion);
                            
                            // 6. ë§µ í¬ì¸íŠ¸ ì¶”ê°€ (ê°œì„ ëœ ë²„ì „)
                            addMapPointsAdvanced(keypoints2, motion);
                            
                            // 7. ë²½ ê°ì§€ (ë‹¤ì¤‘ ë°©ë²•)
                            detectWallsAdvanced(currentFrame);
                            
                            // 8. ë£¨í”„ í´ë¡œì € ê°ì§€
                            detectLoopClosure(currentFrame);
                            
                            confidence = Math.min(95, confidence + 2);
                        }
                    }
                    
                    matches.delete();
                }
                
                // í˜„ì¬ í”„ë ˆì„ì„ ì´ì „ í”„ë ˆì„ìœ¼ë¡œ ì„¤ì •
                previousFrame.delete();
                previousFrame = currentFrame.clone();
                
                // ë©”ëª¨ë¦¬ ì •ë¦¬
                keypoints1.delete();
                descriptors1.delete();
                keypoints2.delete();
                descriptors2.delete();
                
            } catch (error) {
                log(`ê³ ê¸‰ SLAM ì²˜ë¦¬ ì˜¤ë¥˜: ${error.message}`);
                confidence = Math.max(0, confidence - 1);
            }
        }
        
        // í–¥ìƒëœ íŠ¹ì§•ì  ë§¤ì¹­
        function matchFeaturesAdvanced(desc1, desc2) {
            const matches = new cv.DMatchVector();
            descriptorMatcher.match(desc1, desc2, matches);
            
            // ê±°ë¦¬ ê¸°ë°˜ í•„í„°ë§
            const goodMatches = new cv.DMatchVector();
            const distances = [];
            
            for (let i = 0; i < matches.size(); i++) {
                distances.push(matches.get(i).distance);
            }
            
            distances.sort((a, b) => a - b);
            const threshold = distances[Math.floor(distances.length * 0.7)]; // ìƒìœ„ 70% ë§¤ì¹˜ë§Œ ì‚¬ìš©
            
            for (let i = 0; i < matches.size(); i++) {
                const match = matches.get(i);
                if (match.distance < threshold) {
                    goodMatches.push_back(match);
                }
            }
            
            matches.delete();
            return goodMatches;
        }
        
        // RANSAC ì•„ì›ƒë¼ì´ì–´ ì œê±°
        function filterMatchesRANSAC(kp1, kp2, matches) {
            const goodMatches = [];
            const threshold = 3.0; // í”½ì…€ ê±°ë¦¬ ì„ê³„ê°’
            
            for (let i = 0; i < matches.size() && i < 50; i++) {
                const match = matches.get(i);
                const pt1 = kp1.get(match.queryIdx).pt;
                const pt2 = kp2.get(match.trainIdx).pt;
                
                // ê°„ë‹¨í•œ ì¼ê´€ì„± ê²€ì‚¬
                const dx = pt2.x - pt1.x;
                const dy = pt2.y - pt1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 100 && distance > 2) { // í•©ë¦¬ì ì¸ ì›€ì§ì„ë§Œ í—ˆìš©
                    goodMatches.push({pt1, pt2, distance});
                }
            }
            
            return goodMatches;
        }
        
        // ì„¼ì„œ ìœµí•© ì›€ì§ì„ ì¶”ì •
        function estimateMotionWithSensors(kp1, kp2, matches) {
            let dx = 0, dy = 0, dangle = 0;
            
            // ë¹„ì „ ê¸°ë°˜ ì›€ì§ì„ ê³„ì‚°
            for (let match of matches) {
                dx += (match.pt2.x - match.pt1.x);
                dy += (match.pt2.y - match.pt1.y);
            }
            
            if (matches.length > 0) {
                dx /= matches.length;
                dy /= matches.length;
            }
            
            // ì„¼ì„œ ë°ì´í„°ë¡œ ë³´ì •
            const sensorWeight = 0.3; // ì„¼ì„œ ê°€ì¤‘ì¹˜
            const visionWeight = 0.7;  // ë¹„ì „ ê°€ì¤‘ì¹˜
            
            // ìì´ë¡œìŠ¤ì½”í”„ ë°ì´í„°ë¡œ íšŒì „ ë³´ì •
            dangle = gyroData.z * 0.01 * sensorWeight;
            
            // ê°€ì†ë„ê³„ë¡œ ìŠ¤ì¼€ì¼ ë³´ì •
            const accelMagnitude = Math.sqrt(accelData.x**2 + accelData.y**2 + accelData.z**2);
            const speedFactor = Math.min(2.0, Math.max(0.5, 1.0 + (accelMagnitude - 1.0) * 0.1));
            
            // ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ìŠ¤ì¼€ì¼ ì ìš©
            const scale = deviceScale * speedFactor * 0.1;
            
            return {
                dx: -dx * scale * visionWeight,
                dy: -dy * scale * visionWeight,
                dangle: dangle
            };
        }
        
        // í–¥ìƒëœ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        function updatePositionAdvanced(motion) {
            // ìŠ¤ë¬´ë”© í•„í„° ì ìš©
            const smoothing = 0.8;
            
            currentPosition.x += motion.dx * smoothing;
            currentPosition.y += motion.dy * smoothing;
            currentPosition.angle += motion.dangle * smoothing;
            
            // ë§µ ê²½ê³„ ì œí•œ
            currentPosition.x = Math.max(10, Math.min(390, currentPosition.x));
            currentPosition.y = Math.max(10, Math.min(290, currentPosition.y));
            
            // ê°ë„ ì •ê·œí™”
            currentPosition.angle = currentPosition.angle % (2 * Math.PI);
            
            trajectory.push({...currentPosition});
            
            // ê¶¤ì  ê¸¸ì´ ì œí•œ
            if (trajectory.length > 2000) {
                trajectory = trajectory.slice(-1500);
            }
        }
        
        // í–¥ìƒëœ ë§µ í¬ì¸íŠ¸ ì¶”ê°€
        function addMapPointsAdvanced(keypoints, motion) {
            for (let i = 0; i < keypoints.size() && i < 20; i++) {
                const kp = keypoints.get(i);
                
                // íŠ¹ì§•ì  í’ˆì§ˆ í™•ì¸
                if (kp.response > 0.001) { // ê³ í’ˆì§ˆ íŠ¹ì§•ì ë§Œ
                    // í‚¤í¬ì¸íŠ¸ë¥¼ ë§µ ì¢Œí‘œë¡œ ë³€í™˜ (íšŒì „ ê³ ë ¤)
                    const relativeX = (kp.pt.x - 320) * deviceScale * 0.1;
                    const relativeY = (kp.pt.y - 240) * deviceScale * 0.1;
                    
                    // íšŒì „ ë³€í™˜ ì ìš©
                    const cos_a = Math.cos(currentPosition.angle);
                    const sin_a = Math.sin(currentPosition.angle);
                    
                    const mapX = currentPosition.x + relativeX * cos_a - relativeY * sin_a;
                    const mapY = currentPosition.y + relativeX * sin_a + relativeY * cos_a;
                    
                    if (mapX > 0 && mapX < 400 && mapY > 0 && mapY < 300) {
                        mapPoints.push({
                            x: mapX,
                            y: mapY,
                            confidence: kp.response,
                            age: 0
                        });
                    }
                }
            }
            
            // ì˜¤ë˜ëœ í¬ì¸íŠ¸ ì œê±°
            mapPoints = mapPoints.filter(point => point.age++ < 100);
            
            // ë§µ í¬ì¸íŠ¸ ìˆ˜ ì œí•œ
            if (mapPoints.length > 3000) {
                mapPoints = mapPoints.slice(-2000);
            }
        }
        
        // í–¥ìƒëœ ë²½ ê°ì§€
        function detectWallsAdvanced(frame) {
            try {
                // 1. Canny ì—£ì§€ ê²€ì¶œ
                const edges = new cv.Mat();
                cv.Canny(frame, edges, 30, 100, 3);
                
                // 2. ëª¨í´ë¡œì§€ ì—°ì‚°ìœ¼ë¡œ ì—£ì§€ ê°•í™”
                const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);
                
                // 3. Hough ì§ì„  ê²€ì¶œ (í–¥ìƒëœ íŒŒë¼ë¯¸í„°)
                const lines = new cv.Mat();
                cv.HoughLinesP(edges, lines, 1, Math.PI / 180, 30, 20, 5);
                
                // 4. ì§ì„  í•„í„°ë§ ë° ë³‘í•©
                const filteredWalls = [];
                for (let i = 0; i < lines.rows; i++) {
                    const line = lines.data32S.slice(i * 4, (i + 1) * 4);
                    const [x1, y1, x2, y2] = line;
                    
                    // ì§ì„  ê¸¸ì´ í™•ì¸
                    const length = Math.sqrt((x2 - x1)**2 + (y2 - y1)**2);
                    if (length > 15) { // ìµœì†Œ ê¸¸ì´ í•„í„°
                        
                        // í”„ë ˆì„ ì¢Œí‘œë¥¼ ë§µ ì¢Œí‘œë¡œ ë³€í™˜
                        const relX1 = (x1 - 320) * deviceScale * 0.1;
                        const relY1 = (y1 - 240) * deviceScale * 0.1;
                        const relX2 = (x2 - 320) * deviceScale * 0.1;
                        const relY2 = (y2 - 240) * deviceScale * 0.1;
                        
                        // íšŒì „ ë³€í™˜
                        const cos_a = Math.cos(currentPosition.angle);
                        const sin_a = Math.sin(currentPosition.angle);
                        
                        const mapX1 = currentPosition.x + relX1 * cos_a - relY1 * sin_a;
                        const mapY1 = currentPosition.y + relX1 * sin_a + relY1 * cos_a;
                        const mapX2 = currentPosition.x + relX2 * cos_a - relY2 * sin_a;
                        const mapY2 = currentPosition.y + relX2 * sin_a + relY2 * cos_a;
                        
                        filteredWalls.push({
                            x1: mapX1, y1: mapY1,
                            x2: mapX2, y2: mapY2,
                            confidence: 0.8,
                            length: length
                        });
                    }
                }
                
                // 5. ê¸°ì¡´ ë²½ê³¼ ë³‘í•©
                walls = walls.concat(filteredWalls);
                
                edges.delete();
                lines.delete();
                kernel.delete();
                
                // ë²½ ìˆ˜ ì œí•œ
                if (walls.length > 800) {
                    walls = walls.slice(-600);
                }
                
            } catch (error) {
                log(`í–¥ìƒëœ ë²½ ê°ì§€ ì˜¤ë¥˜: ${error.message}`);
            }
        }
        
        // ë£¨í”„ í´ë¡œì € ê°ì§€
        function detectLoopClosure(currentFrame) {
            // ê°„ë‹¨í•œ ë£¨í”„ í´ë¡œì € (í‚¤í”„ë ˆì„ê³¼ ë¹„êµ)
            if (keyframes.length > 5) {
                for (let i = 0; i < keyframes.length - 3; i++) {
                    try {
                        const keyframe = keyframes[i].frame;
                        
                        // íŠ¹ì§•ì  ë§¤ì¹­ìœ¼ë¡œ ìœ ì‚¬ë„ í™•ì¸
                        const kp1 = new cv.KeyPointVector();
                        const desc1 = new cv.Mat();
                        const kp2 = new cv.KeyPointVector();
                        const desc2 = new cv.Mat();
                        
                        detector.detectAndCompute(keyframe, new cv.Mat(), kp1, desc1);
                        detector.detectAndCompute(currentFrame, new cv.Mat(), kp2, desc2);
                        
                        if (desc1.rows > 0 && desc2.rows > 0) {
                            const matches = new cv.DMatchVector();
                            descriptorMatcher.match(desc1, desc2, matches);
                            
                            // ì¢‹ì€ ë§¤ì¹˜ê°€ ë§ìœ¼ë©´ ë£¨í”„ í´ë¡œì €
                            let goodMatches = 0;
                            for (let j = 0; j < matches.size(); j++) {
                                if (matches.get(j).distance < 50) {
                                    goodMatches++;
                                }
                            }
                            
                            if (goodMatches > 30) {
                                log(`ë£¨í”„ í´ë¡œì € ê°ì§€! í‚¤í”„ë ˆì„ ${i}ì™€ ë§¤ì¹­`);
                                confidence = Math.min(95, confidence + 5);
                                
                                // ìœ„ì¹˜ ë³´ì • (ê°„ë‹¨í•œ ë²„ì „)
                                const keyPos = keyframes[i].position;
                                currentPosition.x = (currentPosition.x + keyPos.x) / 2;
                                currentPosition.y = (currentPosition.y + keyPos.y) / 2;
                            }
                            
                            matches.delete();
                        }
                        
                        kp1.delete();
                        desc1.delete();
                        kp2.delete();
                        desc2.delete();
                        
                    } catch (error) {
                        // ì˜¤ë¥˜ ë¬´ì‹œí•˜ê³  ê³„ì†
                    }
                }
            }
        }
        
        // í–¥ìƒëœ ë§µ ê·¸ë¦¬ê¸°
        function drawAdvancedMap() {
            const ctx = mapCanvas.getContext('2d');
            ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
            
            // ë°°ê²½ ê²©ì (ë” ì„¸ë°€í•˜ê²Œ)
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let x = 0; x <= 400; x += 10) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 300);
                ctx.stroke();
            }
            for (let y = 0; y <= 300; y += 10) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(400, y);
                ctx.stroke();
            }
            
            // ì£¼ìš” ê²©ì (20cm ê°„ê²©)
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let x = 0; x <= 400; x += 20) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 300);
                ctx.stroke();
            }
            for (let y = 0; y <= 300; y += 20) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(400, y);
                ctx.stroke();
            }
            
            // ë§µ í¬ì¸íŠ¸ ê·¸ë¦¬ê¸° (ì‹ ë¢°ë„ë³„ ìƒ‰ìƒ)
            mapPoints.forEach(point => {
                const alpha = Math.min(1, point.confidence * 2);
                ctx.fillStyle = `rgba(66, 165, 245, ${alpha})`;
                ctx.beginPath();
                ctx.arc(point.x, point.y, 1.5, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // ë²½ ê·¸ë¦¬ê¸° (ê¸¸ì´ë³„ ë‘ê»˜)
            walls.forEach(wall => {
                const thickness = Math.min(4, Math.max(1, wall.length / 10));
                ctx.strokeStyle = '#f44336';
                ctx.lineWidth = thickness;
                ctx.beginPath();
                ctx.moveTo(wall.x1, wall.y1);
                ctx.lineTo(wall.x2, wall.y2);
                ctx.stroke();
            });
            
            // ê¶¤ì  ê·¸ë¦¬ê¸° (ê·¸ë¼ë°ì´ì…˜)
            if (trajectory.length > 1) {
                for (let i = 1; i < trajectory.length; i++) {
                    const alpha = i / trajectory.length;
                    ctx.strokeStyle = `rgba(76, 175, 80, ${alpha})`;
                    ctx.lineWidth = 2 + alpha;
                    ctx.beginPath();
                    ctx.moveTo(trajectory[i-1].x, trajectory[i-1].y);
                    ctx.lineTo(trajectory[i].x, trajectory[i].y);
                    ctx.stroke();
                }
            }
            
            // í‚¤í”„ë ˆì„ ìœ„ì¹˜ í‘œì‹œ
            keyframes.forEach((kf, index) => {
                ctx.fillStyle = '#9c27b0';
                ctx.beginPath();
                ctx.arc(kf.position.x, kf.position.y, 3, 0, 2 * Math.PI);
                ctx.fill();
                
                // í‚¤í”„ë ˆì„ ë²ˆí˜¸
                ctx.fillStyle = '#fff';
                ctx.font = '8px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(index, kf.position.x, kf.position.y + 2);
            });
            
            // í˜„ì¬ ìœ„ì¹˜ (ë” í¬ê²Œ)
            ctx.fillStyle = '#ff5722';
            ctx.beginPath();
            ctx.arc(currentPosition.x, currentPosition.y, 6, 0, 2 * Math.PI);
            ctx.fill();
            
            // ë°©í–¥ í‘œì‹œ (ë” ì •í™•í•˜ê²Œ)
            const arrowLength = 20;
            const arrowX = currentPosition.x + arrowLength * Math.cos(currentPosition.angle);
            const arrowY = currentPosition.y + arrowLength * Math.sin(currentPosition.angle);
            ctx.strokeStyle = '#ff5722';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(currentPosition.x, currentPosition.y);
            ctx.lineTo(arrowX, arrowY);
            ctx.stroke();
            
            // í™”ì‚´ì´‰
            const arrowAngle = Math.PI / 6;
            const arrowSize = 8;
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(
                arrowX - arrowSize * Math.cos(currentPosition.angle - arrowAngle),
                arrowY - arrowSize * Math.sin(currentPosition.angle - arrowAngle)
            );
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(
                arrowX - arrowSize * Math.cos(currentPosition.angle + arrowAngle),
                arrowY - arrowSize * Math.sin(currentPosition.angle + arrowAngle)
            );
            ctx.stroke();
        }
        
        // ë§µ ì´ˆê¸°í™”
        function clearMap() {
            const ctx = mapCanvas.getContext('2d');
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            
            // ì¤‘ì•™ì  í‘œì‹œ
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.arc(200, 150, 4, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ì‹œì‘ì ', 200, 170);
            
            // ìŠ¤ì¼€ì¼ í‘œì‹œ
            ctx.font = '10px Arial';
            ctx.fillText('20cm', 30, 20);
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(10, 15);
            ctx.lineTo(30, 15);
            ctx.stroke();
        }
        
        // ìŠ¤ìº” ì¤‘ì§€
        function stopScanning() {
            log('ê³ ì •ë°€ ìŠ¤ìº” ì¤‘ì§€');
            isScanning = false;
            
            scanBtn.disabled = false;
            stopBtn.disabled = true;
            saveBtn.disabled = false;
            
            updateStatus('ìŠ¤ìº” ì™„ë£Œ! ê²°ê³¼ë¥¼ í™•ì¸í•˜ê³  ì €ì¥í•˜ì„¸ìš”', 'success');
            
            // ìµœì¢… ë¶„ì„
            analyzeResultsAdvanced();
        }
        
        // í–¥ìƒëœ ê²°ê³¼ ë¶„ì„
        function analyzeResultsAdvanced() {
            // ë°© ê°ì§€ (í´ëŸ¬ìŠ¤í„°ë§ ê°œì„ )
            rooms = detectRoomsAdvanced();
            
            // ìµœì¢… ë§µ ê·¸ë¦¬ê¸°
            drawFinalMapAdvanced();
            
            // ê²°ê³¼ í‘œì‹œ
            document.getElementById('results').style.display = 'block';
            displayResultsAdvanced();
        }
        
        // í–¥ìƒëœ ë°© ê°ì§€
        function detectRoomsAdvanced() {
            const detectedRooms = [];
            
            if (trajectory.length > 100) {
                // ê²½ë¡œ ë¶„ì„ìœ¼ë¡œ ë°© êµ¬ë¶„
                const segments = analyzeTrajectorySegments();
                
                segments.forEach((segment, index) => {
                    const area = calculateSegmentArea(segment);
                    if (area > 5) { // 5ã¡ ì´ìƒë§Œ ë°©ìœ¼ë¡œ ì¸ì •
                        detectedRooms.push({
                            name: `êµ¬ì—­ ${index + 1}`,
                            area: area,
                            confidence: confidence,
                            center: calculateSegmentCenter(segment)
                        });
                    }
                });
            }
            
            return detectedRooms;
        }
        
        // ê¶¤ì  ì„¸ê·¸ë¨¼íŠ¸ ë¶„ì„
        function analyzeTrajectorySegments() {
            const segments = [];
            let currentSegment = [];
            
            for (let i = 1; i < trajectory.length; i++) {
                const dx = trajectory[i].x - trajectory[i-1].x;
                const dy = trajectory[i].y - trajectory[i-1].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                currentSegment.push(trajectory[i]);
                
                // ë°©í–¥ ë³€í™”ê°€ í¬ê±°ë‚˜ ì¼ì • ê±°ë¦¬ ì´ìƒì´ë©´ ìƒˆ ì„¸ê·¸ë¨¼íŠ¸
                if (distance > 50 || currentSegment.length > 200) {
                    if (currentSegment.length > 50) {
                        segments.push([...currentSegment]);
                    }
                    currentSegment = [trajectory[i]];
                }
            }
            
            if (currentSegment.length > 50) {
                segments.push(currentSegment);
            }
            
            return segments;
        }
        
        // ì„¸ê·¸ë¨¼íŠ¸ ë©´ì  ê³„ì‚°
        function calculateSegmentArea(segment) {
            if (segment.length < 3) return 0;
            
            // ê°„ë‹¨í•œ ë‹¤ê°í˜• ë©´ì  ê³„ì‚° (Shoelace formula)
            let area = 0;
            for (let i = 0; i < segment.length - 1; i++) {
                area += segment[i].x * segment[i+1].y - segment[i+1].x * segment[i].y;
            }
            area = Math.abs(area) / 2;
            
            // í”½ì…€ì„ ì‹¤ì œ ë©´ì ìœ¼ë¡œ ë³€í™˜ (ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì ìš©)
            const pixelToMeter = 1 / calibrationData.pixelPerMeter;
            return area * pixelToMeter * pixelToMeter;
        }
        
        // ì„¸ê·¸ë¨¼íŠ¸ ì¤‘ì‹¬ ê³„ì‚°
        function calculateSegmentCenter(segment) {
            let centerX = 0, centerY = 0;
            segment.forEach(point => {
                centerX += point.x;
                centerY += point.y;
            });
            return {
                x: centerX / segment.length,
                y: centerY / segment.length
            };
        }
        
        // í–¥ìƒëœ ìµœì¢… ë§µ ê·¸ë¦¬ê¸°
        function drawFinalMapAdvanced() {
            const ctx = finalMap.getContext('2d');
            ctx.clearRect(0, 0, finalMap.width, finalMap.height);
            
            // ë§µ ìº”ë²„ìŠ¤ ë‚´ìš© ë³µì‚¬
            ctx.drawImage(mapCanvas, 0, 0);
            
            // ë°© ì˜ì—­ í‘œì‹œ
            rooms.forEach((room, index) => {
                const colors = ['rgba(255, 107, 107, 0.3)', 'rgba(78, 205, 196, 0.3)', 'rgba(69, 183, 209, 0.3)'];
                ctx.fillStyle = colors[index % colors.length];
                ctx.beginPath();
                ctx.arc(room.center.x, room.center.y, Math.sqrt(room.area) * 5, 0, 2 * Math.PI);
                ctx.fill();
                
                // ë°© ì´ë¦„
                ctx.fillStyle = '#333';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(room.name, room.center.x, room.center.y);
            });
            
            // ì œëª©
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ğŸš¨ ê³ ì •ë°€ í™”ì¬í˜„ì¥ ìŠ¤ìº” ê²°ê³¼', finalMap.width / 2, 20);
            
            // ìƒì„¸ ë²”ë¡€
            ctx.font = '8px Arial';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#4caf50';
            ctx.fillText('â— ì´ë™ ê²½ë¡œ', 10, 275);
            ctx.fillStyle = '#f44336';
            ctx.fillText('â— ê°ì§€ëœ ë²½', 80, 275);
            ctx.fillStyle = '#9c27b0';
            ctx.fillText('â— í‚¤í”„ë ˆì„', 150, 275);
            ctx.fillStyle = '#ff5722';
            ctx.fillText('â— í˜„ì¬ ìœ„ì¹˜', 220, 275);
            
            // ì •í™•ë„ ì •ë³´
            ctx.fillStyle = '#666';
            ctx.fillText(`ì‹ ë¢°ë„: ${Math.round(confidence)}% | ìŠ¤ì¼€ì¼: ${deviceScale.toFixed(2)}x`, 10, 290);
        }
        
        // í–¥ìƒëœ ê²°ê³¼ í‘œì‹œ
        function displayResultsAdvanced() {
            const roomInfo = document.getElementById('roomInfo');
            let html = '<h4>ğŸ“Š ê³ ì •ë°€ ìŠ¤ìº” ê²°ê³¼</h4>';
            
            // ì „ì²´ í†µê³„
            const totalDistance = calculateTotalDistance();
            const scanTime = Math.round(frameCount * 0.1);
            
            html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 10px 0;">`;
            html += `<div style="text-align: center; padding: 10px; background: #e3f2fd; border-radius: 5px;">`;
            html += `<div style="font-size: 18px; font-weight: bold; color: #1976d2;">${totalDistance.toFixed(1)}m</div>`;
            html += `<div style="font-size: 12px;">ì´ ì´ë™ê±°ë¦¬</div></div>`;
            
            html += `<div style="text-align: center; padding: 10px; background: #e8f5e8; border-radius: 5px;">`;
            html += `<div style="font-size: 18px; font-weight: bold; color: #388e3c;">${Math.round(confidence)}%</div>`;
            html += `<div style="font-size: 12px;">ì‹ ë¢°ë„</div></div>`;
            
            html += `<div style="text-align: center; padding: 10px; background: #fff3e0; border-radius: 5px;">`;
            html += `<div style="font-size: 18px; font-weight: bold; color: #f57c00;">${scanTime}ì´ˆ</div>`;
            html += `<div style="font-size: 12px;">ìŠ¤ìº” ì‹œê°„</div></div>`;
            
            html += `<div style="text-align: center; padding: 10px; background: #f3e5f5; border-radius: 5px;">`;
            html += `<div style="font-size: 18px; font-weight: bold; color: #7b1fa2;">${keyframes.length}</div>`;
            html += `<div style="font-size: 12px;">í‚¤í”„ë ˆì„</div></div>`;
            html += `</div>`;
            
            // í’ˆì§ˆ í‰ê°€
            html += `<div style="background: #f0f4ff; padding: 10px; border-radius: 5px; margin: 10px 0;">`;
            html += `<strong>ğŸ“Š í’ˆì§ˆ í‰ê°€:</strong><br>`;
            html += `â€¢ íŠ¹ì§•ì  í’ˆì§ˆ: ${Math.round(featureQuality)}%<br>`;
            html += `â€¢ ì¡°ëª… í’ˆì§ˆ: ${Math.round(lightingQuality)}%<br>`;
            html += `â€¢ ëª¨ì…˜ ì•ˆì •ì„±: ${Math.round(100 - motionBlur)}%<br>`;
            html += `â€¢ ìº˜ë¦¬ë¸Œë ˆì´ì…˜: ${isCalibrated ? 'âœ… ì™„ë£Œ' : 'âŒ ë¯¸ì™„ë£Œ'}`;
            html += `</div>`;
            
            if (rooms.length > 0) {
                html += `<h5>ğŸ  ê°ì§€ëœ êµ¬ì—­ (${rooms.length}ê°œ):</h5>`;
                rooms.forEach((room, index) => {
                    html += `<div style="padding: 8px; background: #f5f5f5; margin: 5px 0; border-radius: 5px;">`;
                    html += `${room.name}: ${room.area.toFixed(1)}ã¡ (ì‹ ë¢°ë„: ${room.confidence.toFixed(0)}%)`;
                    html += `</div>`;
                });
                
                const totalArea = rooms.reduce((sum, room) => sum + room.area, 0);
                html += `<div style="background: #e8f5e8; padding: 10px; border-radius: 5px; margin: 10px 0;">`;
                html += `<strong>ì´ ë©´ì : ${totalArea.toFixed(1)}ã¡</strong>`;
                html += `</div>`;
            }
            
            html += `<div style="background: #fff3e0; padding: 10px; border-radius: 5px; margin: 10px 0;">`;
            html += `<strong>âš ï¸ ê³ ì •ë°€ ìŠ¤ìº” ì£¼ì˜ì‚¬í•­:</strong><br>`;
            html += `â€¢ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ëœ ê³ ì •ë°€ ê²°ê³¼ì…ë‹ˆë‹¤<br>`;
            html += `â€¢ ì„¼ì„œ ìœµí•©ìœ¼ë¡œ ì •í™•ë„ê°€ í–¥ìƒë˜ì—ˆìŠµë‹ˆë‹¤<br>`;
            html += `â€¢ í™”ì¬í˜„ì¥ êµ¬ì¡° íŒŒì•…ì— í™œìš©í•˜ì„¸ìš”<br>`;
            html += `â€¢ ì¶”ê°€ ë³´ì •ì´ í•„ìš”ì‹œ ìˆ˜ë™ ë³´ì • ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”`;
            html += `</div>`;
            
            roomInfo.innerHTML = html;
        }
        
        // ì´ ì´ë™ê±°ë¦¬ ê³„ì‚°
        function calculateTotalDistance() {
            let distance = 0;
            for (let i = 1; i < trajectory.length; i++) {
                const dx = trajectory[i].x - trajectory[i-1].x;
                const dy = trajectory[i].y - trajectory[i-1].y;
                distance += Math.sqrt(dx * dx + dy * dy);
            }
            // í”½ì…€ì„ ë¯¸í„°ë¡œ ë³€í™˜
            return distance / calibrationData.pixelPerMeter;
        }
        
        // ìˆ˜ë™ ë³´ì • ë„êµ¬ë“¤
        function toggleCorrection() {
            correctionTools.classList.toggle('show');
        }
        
        function updateScaleDisplay() {
            const value = document.getElementById('scaleSlider').value;
            document.getElementById('scaleDisplay').textContent = value + 'x';
        }
        
        function updateRotationDisplay() {
            const value = document.getElementById('rotationSlider').value;
            document.getElementById('rotationDisplay').textContent = value + 'Â°';
        }
        
        function resetCorrection() {
            document.getElementById('scaleSlider').value = 1.0;
            document.getElementById('rotationSlider').value = 0;
            updateScaleDisplay();
            updateRotationDisplay();
        }
        
        function applyCorrection() {
            const scaleCorrection = parseFloat(document.getElementById('scaleSlider').value);
            const rotationCorrection = parseFloat(document.getElementById('rotationSlider').value) * Math.PI / 180;
            
            // ìŠ¤ì¼€ì¼ ë³´ì • ì ìš©
            deviceScale *= scaleCorrection;
            calibrationData.pixelPerMeter *= scaleCorrection;
            
            // íšŒì „ ë³´ì • ì ìš©
            currentPosition.angle += rotationCorrection;
            
            // ì „ì²´ ê¶¤ì ì— ë³´ì • ì ìš©
            trajectory.forEach(point => {
                point.angle += rotationCorrection;
            });
            
            // ë§µ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
            drawAdvancedMap();
            drawFinalMapAdvanced();
            
            log(`ë³´ì • ì ìš©: ìŠ¤ì¼€ì¼ ${scaleCorrection}x, íšŒì „ ${rotationCorrection.toFixed(2)}rad`);
            updateStatus('ë³´ì •ì´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
        }
        
        // ê²°ê³¼ ì €ì¥ (í–¥ìƒëœ ë²„ì „)
        function saveResults() {
            const results = {
                timestamp: new Date().toISOString(),
                scanInfo: {
                    frameCount,
                    featureCount,
                    confidence: Math.round(confidence),
                    duration: Math.round(frameCount * 0.1),
                    totalDistance: calculateTotalDistance(),
                    qualityMetrics: {
                        featureQuality: Math.round(featureQuality),
                        lightingQuality: Math.round(lightingQuality),
                        motionStability: Math.round(100 - motionBlur)
                    }
                },
                calibrationData,
                trajectory: trajectory.slice(0, 500), // ìƒ˜í”Œë§Œ ì €ì¥
                mapPoints: mapPoints.slice(0, 200),
                walls: walls.slice(0, 100),
                rooms,
                keyframes: keyframes.map(kf => ({
                    position: kf.position,
                    timestamp: kf.timestamp
                }))
            };
            
            // JSON íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œ
            const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `high_precision_scan_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            // ì´ë¯¸ì§€ë„ ì €ì¥
            finalMap.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `high_precision_map_${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
            
            log('ê³ ì •ë°€ ê²°ê³¼ ì €ì¥ ì™„ë£Œ');
            updateStatus('ê³ ì •ë°€ ê²°ê³¼ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
        }
        
        // ë””ë²„ê·¸ í† ê¸€
        function toggleDebug() {
            debugInfo.classList.toggle('show-debug');
        }
        
        // ì˜¤ë¥˜ ì²˜ë¦¬
        window.onerror = function(message, source, lineno, colno, error) {
            log(`âŒ ì˜¤ë¥˜: ${message} (${source}:${lineno})`);
            return false;
        };
        
        window.addEventListener('unhandledrejection', function(event) {
            log(`âŒ Promise ì˜¤ë¥˜: ${event.reason}`);
        });
        
        log('ê³ ì •ë°€ í™”ì¬í˜„ì¥ í‰ë©´ë„ ìƒì„±ê¸° ì´ˆê¸°í™” ì™„ë£Œ');
    </script>
</body>
</html>
